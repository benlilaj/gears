#summary Provides the geolocation of a device running a Gears-enabled web browser.
#labels DesignDoc


= Summary =

The Geolocation API allows web apps to retrieve the user's current position.  The API should provide the following features:

  * One-shot position requests (e.g. for recommendations sites -- "where am I right now?")
  * Repeated position updates (e.g. for continuously updating one's location on a map)
  * Ability to get the last-known position cheaply before doing an expensive new request
  * Compatibility with future use as a singleton in the standard DOM (e.g. window.geolocation)
  * Support for alternative location service providers


= API Proposal =

{{{
interface Geolocation {
  // Last known position, or null if there is no last known position.
  readonly Position lastPosition;

  // Get the current position.
  void getCurrentPosition(PositionCallback callback, optional PositionOptions);

  // Watch the current position over time.
  int watchPosition(PositionCallback callback, optional PositionOptions);

  // Stop watching the current position.
  void clearWatch(int watchId);
};


void PositionCallback(Position position);


interface Position {
  readonly double latitude;  // latitude in degrees
  readonly double longitude;  // longitude in degrees
  readonly double altitude;  // height in meters above the WGS 84 reference
                             // ellipsoid, or null if unsupported by device.
  readonly double horizontalAccuracy;  // in meters
  readonly double verticalAccuracy;  // in meters, or null if unsupported
  readonly Date timestamp;
  readonly string errorMessage; // human readable, suitable for logs
  // TODO: Consider adding heading
  // TODO: Consider adding address
  // TODO: Consider adding speed
  // TODO: Consider adding address (maybe requires flag in PositionOptions, since it is relatively expensive)
};


interface PositionOptions {
  // If set, specifies the URL to contact to convert geolocation signals into a
  // position.  Otherwise, only local position sources will be used (e.g. GPS).
  string locationProviderUrl;

  // Set to 'true' to request use of higher power (and battery consumption).
  // This may result in higher accuracy. The default is false.
  bool useHighPower;
};
}}}


= Examples = 

{{{
var geo = google.gears.factory.create('beta.geolocation');

// Get the position.
geo.getCurrentPosition(function(position) {
  updateMap(position.latitude, position.longitude);
});

// Watch the position over time.
var watchId = geo.watchPosition(function(position) {
  updateMap(position.latitude, position.longitude, position.accuracy);
});

geo.clearWatch(watchId);

// Only get the position if the last known position is more than a minute old.
var now = new Date().getTime();
var threshold = now - 60000;

if (geo.lastPosition &&
    geo.lastPosition.timestamp.getTime() > threshold) {
  updateMap2(geo.lastPosition);
} else {
  loc.getCurrentPosition(function(position) {
    updateMap2(position);
  });
}
}}}


= Implementation Details =

The Geolocation API is an abstraction for various location APIs that currently exist on mobile platforms (GPS-based, network/cellid-based). Geolocation implementations could be straightforward mappings to native APIs (e.g the [http://www.forum.nokia.com/document/Cpp_Developers_Library/GUID-96C272CA-2BED-4352-AE7C-E692B193EC06/html/Location_Acquisition_APIIndexPage.html S60 Location Acquisition API]) or have a more complex design that combines several location providers (e.g. a GPS-based provider and a cell id-based provider) and returns the location from the most accurate provider at any given time.

The Gears implementation chooses the location provider to invoke subject to the criteria specified with `PositionOptions`. When location data is requested, the first result that satisfies the criteria is returned via the `PostionCallback` function. Subsequent invocations will always use the most accurate location data available. This caters for the common case where a less accurate fix from a network-based location provider can be obtained quickly followed by a more accurate GPS fix later.


= Privacy =

It must be clear to users when an application is using the Geolocation API.  We could implement one or both of the following UI elements:

  1. *A separate dialog from the Gears security dialog to enable the Geolocation API.* If the general-purpose dialog gave access to position data, it would be easy for users to forget they allowed access to Gears, or to fail to realize enabling Gears also exposes their position data.
  1. *Some persistent UI that indicates the Geolocation API is being used.* For example, there could be a bar across the bottom of the browser with an icon of a globe or map. Perhaps this UI should be 'active' somehow, indicating that something is happening, so that the user cannot forget it is being used.

Communication with the `locationProviderUrl` should use a cookie jar separate from the browser's cookie jar.  Web apps will generally live on a different security origin than third-party location providers.  By using separate cookie jars, a third-party provider cannot correlate location requests with non-location-based visits to that origin.


= Appendix A: Alternate API =

Instead of the Geolocation API described above, Gears could expose only the underlying location signals.  (See "Location Provider Protocol - Request Format" below for the list of signals.)

In many ways the approaches are equivalent.  The signals must be sent _somewhere_ in order to be useful, and that destination can be set as the `locationProviderUrl`.

Still, a lower-level API would be different in several ways:

  * *Consistency* - A low-level API is not directly useful to web app developers, so location providers would be tasked with designing the interface used by web apps.  This gives location providers more flexibility.  At the same time, it hinders web app developers slightly: it becomes more work to integrate geolocation data into an app, and it could become hard to switch between location providers that expose different interfaces.

  * *Privacy* - With a low-level API, there is no need for a separate geolocation cookie jar.  It's also unclear whether separate Gears and Geolocation security dialogs would be useful.  (It would still make sense to indicate when position data is being tracked.)

  * *Surface Area* - The low-level API would be a subset of the proposed spec, which can be seen as an advantage or disadvantage.  There are obvious differences, like removing all the methods described earlier.  There are also less obvious simplifications, like returning only the current signals, rather than any historical data.

  * *Logic* - With a high-level API, it's more obvious how Gears can make decisions like whether to turn on the GPS radio in response to a request.  With a low-level signals-based API, it's unclear whether we can do much more than rate-limiting.


= Appendix B: Location Provider Protocol =

Many devices do not have native access to GPS or other location data. Additionally, GPS can take a long time to get an accurate location fix, drains battery, and does not work indoors. Because of these problems, the location API also has the ability to send various signals that the devices has access to (nearby cell sites, wifi nodes, etc) to a third-party _location service provider_, who can resolve the signals into a location estimate.

The protocol between the device and the location service provider is HTTP POST. The request and response are both formatted as JSON.

== Request Format ==

{{{
{
  version: "1.0",
  host: "maps.google.com",
  home_mobile_country_code: 310,
  home_mobile_network_code: 410,
  radio_type: "gsm",
  cell_towers: [
    {
      cell_id: 42,
      area_code: 415,
      mobile_country_code: 310,
      mobile_network_code: 410,
      age: 0,
      signal_strength: 3,
      timing_advance: 5555
    },
    {
      cell_id: 88,
      area_code: 415,
      mobile_country_code: 310,
      mobile_network_code: 580,
      age: 36000,
      signal_strength: 2,  (TODO: Is this @age, or now? If @age, triangulation uses stale data?)
      timing_advance: 7777
    }
  ],
  wifi_towers: [
    {
      mac_address: "01-23-45-67-89-ab",
      signal_strength: 8
    },
    {
      mac_address: "01-23-45-67-89-ac",
      signal_strength: 4
    }
  ]
}
}}}

=== Request field details ===

|| *Name* || *Description* || *Required* || *Type" ||
|| version || The protocol version. Currently, this is "1.0". || Yes || string ||
|| host || The host of the web page that is requesting the location. || Yes || string ||
|| home_mobile_country_code || The mobile country code for the device's home network || No || int32 ||
|| home_mobile_network_code || The mobile network code for the device's home network || No || int32 ||
|| radio_type || Mobile radio type. _TODO: Can somebody expand on why this is necessary/useful?_ || No || string (gsm|cdma|wcdma) ||
|| cell_towers || Array of cell-id data objects. See description of cell-id below. || If wifi_data not present || array ||
|| wifi_towers || Array of wifi-id data objects. See description of wifi-id below. || If cellid_data not present || array ||

=== Cell-Id data elements ===

|| *Name* || *Description* || *Required* || *Type" ||
|| cell_id || Unique identifier of the cell. || Yes || string ||
|| area_code || _TODO: explanation required_ || Yes || int16 ||
|| mobile_country_code || Mobile country code for cell || No || int16 ||
|| mobile_network_code || Mobile network code for cell || No || int16 ||
|| age || Number of milliseconds since this cell was primary. If zero, this cell is primary currently. || No || int16 ||
|| signal_strength || Radio signal strength measured in dBm. || No || int16 ||
|| timing_advance || Represents the distance from the cell tower. Each unit is roughly 550 meters. || No || int8 ||

=== Wifi-Id data elements ===

|| *Name* || *Description* || *Required* || *Type" ||
|| mac_address || The mac address of the wifi node. || Yes || string ||
|| signal_strength || Current signal strength measured in dBm. || No || int16 ||

== Response Format ==

The response format is also JSON. An example response is:

{{{
{
  location: {
    latitude:1234123,
    longitude:-2132362,
    accuracy:1200,
    address:"mountain view, california" [ TODO: Remove if not used in API? ]
  }
}
}}}

=== Response format details ===

If the request format is invalid, the server responds with HTTP status 400. The details of the error should be plain text in the response. The API returns this error text in the Position object's `errorMessage` property. 

If the request format is valid, the server replies with HTTP status 200. If the location was successfully resolved, the location object is populated with the details. Otherwise, it is null.

|| *Name* || *Description* || *Required* || *Type" ||
|| latitude || Latitude of the fix, in degrees. || Yes || double ||
|| longitude || Longitude of the fix, in degrees. || Yes || double ||
|| accuracy || The accuracy of the fix, in meters. || Yes || double ||
|| address || The address of the fix. May not be available from some providers. || No || string ||
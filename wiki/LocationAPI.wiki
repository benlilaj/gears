#summary Provides the geolocation of a device running a Gears-enabled web browser.
#labels DesignDoc


= Summary =

The Geolocation API allows web apps to retrieve the user's current position.  The API should provide the following features:

  * One-shot position requests (e.g. for recommendations sites -- "where am I right now?")
  * Repeated position updates (e.g. for continuously updating one's location on a map)
  * Ability to get the last-known position cheaply before doing an expensive new request
  * Compatibility with future use as a singleton in the standard DOM (e.g. window.geolocation)


= API Proposal =

{{{
interface Geolocation {
  // Last known position, or null if there is no last known position.
  readonly Position lastPosition;

  // Get the current position.
  void getCurrentPosition(PositionCallback callback, optional PositionOptions);

  // Watch the current position over time.
  int watchPosition(PositionCallback callback, optional PositionOptions);

  // Stop watching the current position.
  void clearWatch(int watchId);
};


void PositionCallback(Position position);


interface Position {
  readonly double latitude;  // latitude in degrees
  readonly double longitude;  // longitude in degrees
  readonly double altitude;  // height in meters above the WGS 84 reference
                             // ellipsoid, or null if unsupported by device.
  readonly double horizontalAccuracy;  // in meters
  readonly double verticalAccuracy;  // in meters, or null if unsupported
  readonly Date timestamp;      // time when location was established
  readonly string errorMessage; // human readable, suitable for logs
  readonly Address address;     // reverse geocoded address, if requested and available
  // TODO: Consider adding heading
  // TODO: Consider adding speed
};

interface Address {
  readonly string street;       // street address
  readonly string postalCode;   // postal code
  readonly string city;         // city name
  readonly string county;       // county name
  readonly string region;       // region, e.g. a state in the US
  readonly string country;      // country
  readonly string countryCode;  // country code (ISO 3166-1)
  // TODO: Internationalize this structure further
}

interface PositionOptions {
  // Optional. Provides a hint that the application would like to receive the
  // best possible results. This may result in slower response times or
  // increased battery consumption. The user may also deny this capability,
  // or the device may not be able to provide more accurate results than if
  // the flag wasn't specified.
  bool enableHighAccuracy;

  // Optional. Requests reverse geocoded address information as part of
  // the position data. Reverse geocoding is not performed if this flag is not
  // specified or set to false.
  bool requestAddress;

  // Optional. This is a Gears extension that specifies one or more URLs to
  // contact to convert geolocation signals into positions. Each URL is
  // queried and the one that returns the highest accuracy position is
  // returned. If unset, the  defaults to a single Google-implemented service.
  // The array can also be cleared, or set to null, so that no location
  // providers will be used.
  // For more information on the protocol that Gears uses to communicate with
  // location providers, see Appendix B.
  string[] gearsLocationProviderUrls;

  // TODO: Consider adding distanceThreshold (for use with watch())
};
}}}


= Examples = 

{{{
var geo = google.gears.factory.create('beta.geolocation');

// Get the position.
geo.getCurrentPosition(function(position) {
  updateMap(position.latitude, position.longitude);
});

// Watch the position over time.
var watchId = geo.watchPosition(function(position) {
  updateMap(position.latitude, position.longitude, position.accuracy);
});

geo.clearWatch(watchId);

// Only get the position if the last known position is more than a minute old.
var now = new Date().getTime();
var threshold = now - 60000;

if (geo.lastPosition &&
    geo.lastPosition.timestamp.getTime() > threshold) {
  updateMap2(geo.lastPosition);
} else {
  loc.getCurrentPosition(function(position) {
    updateMap2(position);
  });
}
}}}


= Implementation Details =

The Geolocation API is an abstraction for various location APIs that currently exist on mobile platforms (GPS-based, network/cellid-based). Geolocation implementations could be straightforward mappings to native APIs (e.g the [http://www.forum.nokia.com/document/Cpp_Developers_Library/GUID-96C272CA-2BED-4352-AE7C-E692B193EC06/html/Location_Acquisition_APIIndexPage.html S60 Location Acquisition API]) or have a more complex design that combines several location providers (e.g. a GPS-based provider and a cell id-based provider) and returns the location from the most accurate provider at any given time.

The Gears implementation chooses the location provider to invoke subject to the criteria specified with `PositionOptions`. When location data is requested, the first result that satisfies the criteria is returned via the `PostionCallback` function. Subsequent invocations will always use the most accurate location data available. This caters for the common case where a less accurate fix from a network-based location provider can be obtained quickly followed by a more accurate GPS fix later.


= Privacy =

It must be clear to users when an application is using the Geolocation API.  We could implement one or both of the following UI elements:

  1. *A separate dialog from the Gears security dialog to enable the Geolocation API.* If the general-purpose dialog gave access to position data, it would be easy for users to forget they allowed access to Gears, or to fail to realize enabling Gears also exposes their position data.
  1. *Some persistent UI that indicates the Geolocation API is being used.* For example, there could be a bar across the bottom of the browser with an icon of a globe or map. Perhaps this UI should be 'active' somehow, indicating that something is happening, so that the user cannot forget it is being used.


= Appendix A: Alternate API =

Instead of the Geolocation API described above, Gears could expose only the underlying location signals.  (See "Location Provider Protocol - Request Format" below for the list of signals.)

In many ways the approaches are equivalent.  The signals must be sent _somewhere_ in order to be useful, and that destination can be set as the `locationProviderUrl`.

Still, a lower-level API would be different in several ways:

  * *Consistency* - A low-level API is not directly useful to web app developers, so location providers would be tasked with designing the interface used by web apps.  This gives location providers more flexibility.  At the same time, it hinders web app developers slightly: it becomes more work to integrate geolocation data into an app, and it could become hard to switch between location providers that expose different interfaces.

  * *Privacy* - With a low-level API, it's unclear whether separate Gears and Geolocation security dialogs would be useful.  (It would still make sense to indicate when position data is being tracked.)

  * *Surface Area* - The low-level API would be a subset of the proposed spec, which can be seen as an advantage or disadvantage.  There are obvious differences, like removing all the methods described earlier.  There are also less obvious simplifications, like returning only the current signals, rather than any historical data.

  * *Logic* - With a high-level API, it's more obvious how Gears can make decisions like whether to turn on the GPS radio in response to a request.  With a low-level signals-based API, it's unclear whether we can do much more than rate-limiting.


= Appendix B: Location Provider Protocol =

Many devices do not have native access to GPS or other location data. Additionally, GPS can take a long time to get an accurate location fix, drains battery, and does not work indoors. Because of these problems, the location API also has the ability to send various signals that the devices has access to (nearby cell sites, wifi nodes, etc) to a third-party _location service provider_, who can resolve the signals into a location estimate.

The protocol between the device and the location service provider is HTTP POST. The request and response are both formatted as JSON.

== Request Format ==

{{{
{
  version: "1.0",
  host: "maps.google.com",
  home_mobile_country_code: 310,
  home_mobile_network_code: 410,
  radio_type: "gsm",
  carrier: "Vodafone",
  cell_towers: [
    {
      cell_id: 42,
      location_area_code: 415,
      mobile_country_code: 310,
      mobile_network_code: 410,
      age: 0,
      signal_strength: -60,
      timing_advance: 5555
    },
    {
      cell_id: 88,
      location_area_code: 415,
      mobile_country_code: 310,
      mobile_network_code: 580,
      age: 0,
      signal_strength: -70,
      timing_advance: 7777
    }
  ],
  wifi_towers: [
    {
      mac_address: "01-23-45-67-89-ab",
      signal_strength: 8,
      age: 0
    },
    {
      mac_address: "01-23-45-67-89-ac",
      signal_strength: 4,
      age: 0
    }
  ]
}
}}}

=== Request field details ===

|| *Name* || *Description* || *Required* || *Type* ||
|| version || The protocol version. Currently, this is "1.0". || Yes || string ||
|| host || The host of the web page that is requesting the location. || Yes || string ||
|| home_mobile_country_code || The mobile country code for the device's home network || No || int32 ||
|| home_mobile_network_code || The mobile network code for the device's home network || No || int32 ||
|| radio_type || Mobile radio type. _TODO: Can somebody expand on why this is necessary/useful?_ || No || string (gsm|cdma|wcdma) ||
|| carrier || Carrier name. Used to help disambiguate MCC/MNC || No || string ||
|| cell_towers || Array of cell-id data objects. See description of cell-id below. || No || array ||
|| wifi_towers || Array of wifi-id data objects. See description of wifi-id below. || No || array ||

=== Cell-Id data elements ===

|| *Name* || *Description* || *Required* || *Type* ||
|| cell_id || Unique identifier of the cell. || Yes || string ||
|| location_area_code || Location Area Code (LAC) assigned to the current location area || Yes || int16 ||
|| mobile_country_code || Mobile Country Code (MCC) for cell || No || int16 ||
|| mobile_network_code || Mobile Network Code (MNC) for cell || No || int16 ||
|| age || The number of milliseconds since this cell was primary. If age is 0, the cell_id represents a current measurement.  || No || int16 ||
|| signal_strength || Radio signal strength measured in dBm. || No || int16 ||
|| timing_advance || Represents the distance from the cell tower. Each unit is roughly 550 meters. || No || int8 ||

=== Wifi-Id data elements ===

|| *Name* || *Description* || *Required* || *Type* ||
|| mac_address || The mac address of the wifi node. || Yes || string ||
|| signal_strength || Current signal strength measured in dBm. || No || int16 ||
|| age || The number of milliseconds since this access point was detected. If age is 0, the mac_address represents a current measurement. || No || int16 ||

== Response Format ==

The response format is also JSON. An example response is:

{{{
{
  location: {
    latitude:1234123,
    longitude:-2132362,
    altitude: 30,
    horizontal_accuracy:1200,
    vertical_accuracy: 10,
    address:{
      street:"100 Amphibian Walkway",
      postal_code:94043,
      city:"Mountain View",
      county:"Mountain View County",
      region:"California",
      country:"United States of America",
      country_code:"US"
    }
  }
}
}}}

=== Response format details ===

If the request format is invalid, the server responds with HTTP status 400. The details of the error should be plain text in the response. The API returns this error text in the Position object's `errorMessage` property. 

If the request format is valid, the server replies with HTTP status 200. If the location was successfully resolved, the location object is populated with the details. Otherwise, it is null.

|| *Name* || *Description* || *Required* || *Type* ||
|| latitude || Latitude of the fix, in degrees. || Yes || double ||
|| longitude || Longitude of the fix, in degrees. || Yes || double ||
|| altitude || Altitude of the fix, in meters. || No || int ||
|| horizontal_accuracy || The horizontal accuracy of the fix, in meters at a 95% confidence level. Location providers that cannot determine an accuracy should set this value to NaN. TODO: Should we just make this optional? TODO: Should this be an int? || Yes || double ||
|| vertical_accuracy || The vertical accuracy of the fix, in meters. || No || int ||
|| address || The address of the fix if requested and available. Follows the definition of the Address interface defined above. || No || string ||
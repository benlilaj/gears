#summary Off-screen photo manipulation

= Introduction =
The purpose of this module is to provide programmatic support for off-screen photo manipulation on the browser.

= Requirements =
  #  V1 features (Basic):
    * Basic operations (crop, resize, scale, rotate)
    * Primitives (affine transforms, color transforms, convolution matrices, lookup tables)
    * Draw image onto canvas from local file / remote URL
    * Save image (after manipulation) onto local file / post it to a remote URL (We get this functionality by virtue of using the Blob abstraction)
    * Integration with Gears Blob and URL capture
    * Support for BMP, PNG and JPEG formats
    * Annotation (support for basic text)
  # Beyond V1 (Advanced):
    * Rendering on screen (real-time as opposed to via the BMP encoded capture URL through HTTP)
    * Clippings of arbitrary shape
    * Drawing primitives
    * Support color lookup tables
    * Cool Photo stuff (Red-eye removal, smart scissors, magic wand, etc...)
    * Support other color depths (<>32 bpp)
    * Better support for non-destructive edits

= JS interface =
We model the API based on the _HTML5CanvasElement_ in the HTML5 spec. Please refer to http://www.whatwg.org/specs/web-apps/current-work/multipage/section-the-canvas.html#the-canvas for details.

*_Canvas class:_*
{{{
Canvas class
{  
  // Throws away the existing contents of the canvas.
  // Sets the canvas's dimensions to those of the image in the blob.
  void load(Blob blob);

  
  // Exports this canvas as a blob. This is a snapshot; updates to the canvas are not reflected in the blob.
  // Supported formats: JPEG, PNG, BMP
  // 'attributes' is a map of key-value pairs. 
  // These are the available keys, all optional:
  //      colorMode -- one of the strings "RGBA_32" and "RGB_24".
  //      indexed -- boolean. defaults to false unless palette is specified.
  //      palette -- an array of colors (as integer values). Explicitly specifying indexed = false while passing in a palette is an error.
  //      compressionQuality -- float between 0.0 (small size) and 1.0 (good quality). only for JPEG.
  //      interlaced -- boolean.
  Blob toBlob(optional String mimeType, optional Map attributes);

  Canvas clone();

  // The palette of the image, if the canvas was load()ed from an indexed mode image.
  // Note that on load, the image is converted to RGB; the palette is preserved in case you want
  // to export the image back to indexed mode, but the canvas itself doesn't have an indexed mode.
  // The palette is an array of color values.
  readonly attribute array palette;

  // The functions below change the pixels of the canvas in place, as opposed to scale, rotate, etc 
  // which only set the current transformation matrix that affects future drawing operations.

  // This method ignores the state of the 2d context (see below).
  void crop(int x, int y, int width, int height);
 
  // This method ignores the state of the 2d context.
  // Note: Scales up or down the contents of the canvas using interpolation, as opposed to creating blank pixels or cropping.
  void resize(int width, int height);



  // COMMON WITH HTML CANVAS
  attribute unsigned long width;
  attribute unsigned long height;

  // returns a context
  CanvasRenderingContext2D getContext(string contextId);
};
}}}

*_CanvasRenderingContext2D class:_*

As in HTML Canvas, our context has a state, which is a subset of the state in HTML Canvas's context. Our state consists of:
  * The current transformation matrix
  * The current clipping region (once we add support for this after V1)
  * globalAlpha, globalCompositeOperation and fillStyle. HTML Canvas supports a richer state with more attributes pertaining to drawing that we don't support. See the spec for details.

The 'transform' function just sets the current transformation matrix and does not apply it on the underlying image on the canvas. Just as with HTML Canvas, the drawing functions (drawImage, clearRect, fillRect, strokeRect below) respect the state, and apply the necessary transforms on the clipping region. However color transforms, convolution transforms, etc are not part of the state, and invocations of these functions apply the changes on the underlying image directly. Hence, functions such as 'crop', 'resize', etc. apply the changes right then, whereas 'scale', 'rotate', etc just update the state (the transformation matrix to be precise) and the operations are applied only when a draw function is called.

{{{
CanvasRenderingContext2D class
{
  // ----- THE FOLLOWING ARE FROM HTML CANVAS -------
  // Please see the canvas spec at http://www.whatwg.org/specs/web-apps/current-work/#canvas

  // back-reference to the canvas:
  readonly attribute Canvas canvas;

  // (default 1.0)
  attribute float globalAlpha;
 
  // we only support 'source-over' and 'copy'. Default: 'source-over'.
  attribute string globalCompositeOperation; 

  // note: must be a color, not a gradient or pattern; we don't support those.
  attribute string fillStyle; 
  
  // saves current state on stack.
  void save();
  // pops a state object from the stack and sets the current state to that state.
  void restore(); 
 
  // drawing rectangles
  void clearRect(int x, int y, int w, int h);
  // see fillStyle.
  void fillRect(int x, int y, int w, int h); 
  // does not support stroke styles; draws a one-pixel border.  
  void strokeRect(int x, int y, int w, int h);
  
  // affine transformations (default transform is the identity matrix)
  void scale(float x, float y);
  void rotate(float angle); // in radians.
  void translate(float x, float y);
  void transform(float m11, float m12, float m21, float m22, float dx, float dy);
  void setTransform(float m11, float m12, float m21, float m22, float dx, float dy);

  ImageData createImageData(int sw, int sh);
  ImageData getImageData(int sx, int sy, int sw, int sh);
  void putImageData(ImageData imagedata, int dx, int dy);
  void putImageData(ImageData imagedata, int dx, int dy, int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight);




  // -------- THE FOLLOWING ARE ADDITIONAL ABSTRACTIONS WE SUPPORT ------------

  // 4x5 matrix for RGBA images and 3x4 for RGB.
  // Referring to the color matrix as 'a', here's how this function works (for RGBA):
  // redResult = a[0] * srcR + a[1] * srcG + a[2] * srcB + a[3] * srcA + a[4]
  // greenResult = a[5] * srcR + a[6] * srcG + a[7] * srcB + a[8] * srcA + a[9]
  // blueResult = a[10] * srcR + a[11] * srcG + a[12] * srcB + a[13] * srcA + a[14]
  // alphaResult = a[15] * srcR + a[16] * srcG + a[17] * srcB + a[18] * srcA + a[19]
  // 
  // If the color mode is RGB, the last row and the penultimate column disappear.
  // 
  // Note that the source and result values are expressed as floats between 0.0 and 1.0 so that they are independent of color depth.
  // 
  // The identity matrix has a[0] = a[6] = a[12] = a[18] = 1 with other elements being 0.
  void colorTransform(float[] colorMatrix);
 
  // Computes the color of each pixel by taking a weighted mean of its surrounding pixels' colors, and then adding the bias, if it's supplied.
  // The argument specifies the weights, with the center element of the matrix representing the source pixel's weight and 
  // surrounding elements in the matrix representing the surrounding pixels' weights.
  // Unlike a color matrix, a convolution matrix's size isn't fixed.
  // For pixels that are off the source image, the input image is extended along each of its borders infinitely by duplicating the color values at the given edge of the input image.
  // If applyToAlpha is true, the convolution is applied to the alpha channel in addition to the R, G and B channels. The default is false.
  void convolutionTransform(float[] convolutionMatrix, optional float bias, optional boolean applyToAlpha);
 
  // Allows fractional radii.
  // Takes the median of all pixels within the specified distance from the target pixel.
  // Works component-wise, of course. First premultiplies alpha, and then takes median
  // of R, G and B components separately.
  // After the filter finishes, all pixels have alpha 1.0.
  void medianFilter(float radius);
 
  // x, y, width, height identify a bounding box into which the text is drawn. 
  // If width and height are not specified, the bounding box extends to the last row or column of the canvas.
  // attributes can have the following keys:
  //   center: boolean, centers the text within the bounding box, as opposed to left align (default).
  //   bold: boolean
  //   italic: boolean
  //   underline: boolean
  //   wrap: boolean, specifies that at the right edge of the bounding box, text is wrapped to the next line instead of truncating it (default).
  //   singleLine: treat newlines and tab characters as single spaces,
  //     thus forcing the output to one line. Defaults to false. Cannot be used along with wrap.
  // Need to guarantee consistent rendering across all platforms. We're thinking of using FreeType.
  void drawText(String text, String font, int size, int x, int y, optional int width, optional int height, optional object attributes);

  void drawImage(Canvas image, int dx, int dy);
  void drawImage(Canvas image, int dx, int dy, int dw, int dh);
  void drawImage(Canvas image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);
 
  // similar to putImageData except that it respects the current state.
  // Useful for drawing custom shapes into an ImageData and then compositing that into the canvas.
  void drawImageData(ImageData imagedata, int sx, int sy, int sw, int sh, int dx, int dy);




  // ----- CONVENIENCE FUNCTIONS FOR COMMON OPERATIONS --------
  // These build on top of the primitives above.

  // Equivalent to a call to colorTransform() with a[4] = a[9] = a[14] = delta, and other
  // elements having values from the identity matrix. 
  // This method adds delta to each color channel.
  // delta = -1.0 => fully black image, 0.0 => original image, 1.0 => fully white image.
  void adjustBrightness(float delta);

  void adjustContrast(float contrast);

  // Equivalent a call to colorTransform() with
  //    a[1] = (1.0-s)*rwgt + s;
  //    a[2] = (1.0-s)*rwgt;
  //    a[3] = (1.0-s)*rwgt;
  //    a[5] = (1.0-s)*gwgt;
  //    a[6] = (1.0-s)*gwgt + s;
  //    a[7] = (1.0-s)*gwgt;
  //    a[10] = (1.0-s)*bwgt;
  //    a[11] = (1.0-s)*bwgt;
  //    a[12] = (1.0-s)*bwgt + s;
  //
  // where s is the saturation value (the argument)
  // and (rwgt, gwgt, bwgt) = (0.3086, 0.6094, 0.0820)  [the standard luminance vector]
  //
  // saturation = -1.0 => invert colors, 0.0 => grayscale, 1.0 => original image.
  // This function preserves luminance.
  void adjustSaturation(float saturation);
 
  // Rotates colors on the color wheel while preserving luminance.
  void adjustHue(float angle); // in radians.

  void blur(float factor, int radius);
  void sharpen(float factor, int radius);

  void resetTransform(); 
};
}}}

*_ImageData class:_*
{{{
ImageData class {
  readonly attribute long int width;
  readonly attribute long int height;
  readonly attribute int[] data;
};
}}}

= Deviations from HTML5 =
Unlike the HTML5 canvas, which can be onscreen (part of the DOM) or not (instantiated using Javascript), we are purely an offscreen canvas as of v1, with export to a URL for display as an image. Also, the Gears canvas can be used from worker threads. Here are the other changes:

  *  Added Text support (for annotation support)
  * Added primitives for color transformation, convolution and lookup tables.
  * Drawing of arbitrary paths not supported yet.
  * No support for clipping regions, gradients, patterns, shadows, strokes and line styles.
  * We export to blobs, which can be uploaded to http servers or exported as a URL on the LocalServer; we do not export to data URIs. This is because exporting to a data URI involves base64-encoding the image, which makes it bigger.
  * We do not support the drawImage functions that take in either a HTMLImageElement or a HTMLCanvasElement as a parameter. It is hard to get efficient access to the underlying image data. (We can work around by fetching the source again, or getting a handle to the data URI but all of this is going to be inefficient).

= Sample Code =
*_Example 1: Downloads an image from a server, crops and resizes it, displays the result and uploads it_*:
{{{
var request = google.gears.factory.create('httprequest');
var serverUrl = 'http://picasaweb.google.com/photo/23432094834';
request.open('GET', serverUrl);
request.onreadystatechange = function() {
  if (request.readyState == 4) {
    process(request.responseBlob);
  }
};
request.send();

function process(var srcBlob) {
  var canvas = google.gears.factory.create('canvas');
  canvas.load(srcBlob);

  var context = canvas.getContext('2d');
  // crop out 10 pixels on each side.
  context.crop(10, 10, canvas.width - 20, canvas.height - 20);
  context.resize(1024, 768);

  var destBlob = canvas.toBlob();

  // update on screen:
  var localServer = google.gears.factory.create('localserver');
  var store = localServer.createStore(STORE_NAME);
  store.captureBlob(destBlob, IMAGE_URL);
  var img = document.getElementById('myImage');
  img.src = IMAGE_URL;

  // now upload to server:
  request = google.gears.factory.create('httprequest');
  request.open('PUT', serverUrl);
  request.onreadystatechange = function() {
    if (request.readyState == 4) {
      alert('Upload finished!');
    }
  }
  request.sendBlob(destBlob);
};
}}}

*_Example 2: Performs some more image operations and draws text_*:
{{{
// load the image as above.

function process(var srcBlob) {
  var canvas = google.gears.factory.create('canvas');
  canvas.load(srcBlob);
  
  var context = canvas.getContext('2d');
  context.crop(10, 10, canvas.width - 20, canvas.height - 20); 
  context.resize(1024, 768);

  // rotate the image:
  var destCanvas = google.gears.factory.create('canvas');
  var destContext = destCanvas.getContext('2d');

  // NOTE: does not rotate the image in place;
  // instead sets the current transformation matrix for future draw operations.
  // This is how Canvas works.
  destContext.rotate(0.2);

  destContext.draw(canvas);
  destContext.resetTransform();
  destContext.adjustBrightness(0.2);
  destContext.drawText(950, 100, 'The quick brown fox jumped over the lazy dog', 'Times New Roman', 14, {
      'bold': true,
      'italics': true,
      'wrap': true });

  var destBlob = destCanvas.toBlob("image/jpeg", {
      'interlaced': true,
      'colorMode': canvas.RGB_24,
      'compressionQuality':0.7});

  // display and upload the output blob as in the previous example.
}
}}}

= Points to ponder =

*_Undo_*:

Right now the way an undo can be implemented using the above API is to either clone the canvas after each operation or keep track of the initial state and the list of operations applied on it, so that one can undo to any point by applying some of the operations.

= Beyond V1 =
*_Updates to CanvasRenderingContext2D class:_*
{{{
  // TODO: add EXIF stuff here.

  // ----- NEW ABSTRACTION ------------
  // TODO: need to add an abstraction to support color lookup tables.

  // ------ CLIP REGION SUPPORT (FROM HTML5) ---------
  // assign undefined to set the clip region to the whole canvas.
  // may be arbitrarily shaped, in general, not necessarily rectangular.
  // once clipRegion is added, it will be part of the state, and drawing operations and various image operations
  // (color matrix, median filter, ...) will respect the clip region.
  attribute ClipRegion clipRegion; 

  // returns the new clip region; does not set it as the current clip region.
  ClipRegion defineRectangularClipRegion(int x, int y, int width, int height);

  // copies the pixels selected in this clip region to a new canvas and returns it.
  // The returned canvas is the smallest rectangle that can hold all selected pixels.
  // Since the clip region may be non-rectangular, unselected pixels may be present in the
  // returned canvas, but with alpha = 0.
  Canvas getPixels(ClipRegion clipRegion);
};
}}}

*_Clip Region:_*
{{{
// ----- FROM HTML5 --------
class ClipRegion {
  void add(ClipRegion other);
  void subtract(ClipRegion other);
  void invert();

  ClipRegion clone();
};
}}}

*_Cool photo manipulation stuff:_*
{{{
class PhotoUtils { 
 // Utility class that can perform operations on a canvas 

 // TODO: Need to add the following abstractions:
 // 1. RED-EYE Correction
 // 2. Auto Color Correction
 // 3. Magic Wand

};
}}}
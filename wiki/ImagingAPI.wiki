#summary Off-screen photo manipulation

= Introduction =
The purpose of this module is to provide programmatic support for off-screen in-memory photo manipulation on the browser.

= Requirements =
  #  V1 features (Basic):
    * Basic operations (crop, resize, scale, rotate)
    * Primitives (affine transforms, color transforms, convolution matrices, lookup tables)
    * Draw image onto canvas from local file / remote URL
    * Save image (after manipulation) onto local file / post it to a remote URL
    * Integration with Gears Blob and URL capture
    * Support for BMP, PNG and JPEG formats
    * Annotation (support for basic text)
  # Beyond V1 (Advanced):
    * Rendering on screen (real-time as opposed to via the BMP encoded capture URL through HTTP)
    * Clippings of arbitrary shape
    * Drawing primitives
    * Cool Photo stuff (Red-eye removal, smart scissors, magic wand, etc...)
    * Support other color depths (<>32 bpp)
    * Better support for non-destructive edits

= JS interface =
We model the API based on the _HTML5CanvasElement_ in the HTML5 spec. Look at http://www.whatwg.org/specs/web-apps/current-work/#canvas for details.

*_Canvas class:_*
{{{
Canvas class
{  
  // Exports this canvas as a blob. This is a snapshot; updates to the canvas are not reflected in the blob.
  // Supported formats: JPEG, PNG, BMP
  // 'attributes' is a map of key-value pairs. 
  // These are the available keys, all optional:
  //      indexed -- boolean. defaults to false unless palette is specified.
  //      palette -- an array of colors (as integer values). Explicitly specifying indexed = false while passing in a palette is an error.
  //      compressionFactor -- float between 0.0 (small size) and 1.0 (good quality). only for JPEG.
  //      interlaced -- boolean.
  Blob toBlob(optional String mimeType, optional Map attributes);
      
  // COMMON WITH HTML CANVAS
  attribute unsigned long width;
  attribute unsigned long height;

  // the palette of the image, if the canvas was load()ed from an indexed mode image.
  // Note that on load, the image is converted to RGB; the palette is preserved in case you want
  // to export the image back to indexed mode, but the canvas itself doesn't have an indexed mode.
  readonly attribute palette;

  // returns a Gears object, CanvasRenderingContext2D (only this context is supported currently).
  DOMObject getContext(DOMString contextId);
};
}}}

*_CanvasRenderingContext2D class:_*
{{{
CanvasRenderingContext2D class
{
  // JUST AS WITH HTML CANVAS, THE DRAWING FUNCTIONS (drawImage, clearRect, fillRect, strokeRect) RESPECT THE STATE.
  // AND ONLY THE DRAWING FUNCTIONS DO. 

  // 4x5 matrix for RGBA images and 3x4 for RGB.
  // TODO: Or is it better to take 4x5 consistently and ignore the alpha row and column if the image is RGB?
  // See http://www.adobe.com/devnet/flash/articles/matrix_transformations_04.html
  void colorTransform(float[] colorMatrix);
 
  // see http://www.adobe.com/devnet/flash/articles/matrix_transformations_05.html
  void convolutionTransform(float[] convolutionMatrix);
 
  void medianFilter(float radius);
 
  // x, y, width, height identify a bounding box into which the text is drawn. 
  // If width and height are not specified, the bounding box extends to the last row or column of the canvas.
  // attributes can have the following keys:
  //   center: boolean, centers the text within the bounding box, as opposed to left align (default).
  //   bold: boolean
  //   italic: boolean
  //   underline: boolean
  //   wrap: boolean, specifies that at the right edge of the bounding box, text is wrapped to the next line instead of truncating it (default).
  //   singleLine: treat newlines and tab characters as single spaces,
  //     thus forcing the output to one line. Defaults to false. Cannot be used along with wrap.
  // Need to guarantee consistent rendering across all platforms. We're thinking of using FreeType.
  void drawText(String text, String font, int size, int x, int y, optional int width, optional int height, optional object attributes);

  // Throws away the existing contents of the canvas.
  // Sets the canvas's dimensions to those of the image in the blob.
  void load(Blob blob);

  void drawImage(Canvas image, int dx, int dy);
  void drawImage(Canvas image, int dx, int dy, int dw, int dh);
  void drawImage(Canvas image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);
 
  // similar to putImageData except that it respects the current state.
  // Useful for drawing custom shapes into an ImageData and then compositing that into the canvas.
  void drawImageData(ImageData imagedata, int sx, int sy, int sw, int sh, int dx, int dy);


  // ----- CONVENIENCE FUNCTIONS FOR COMMON OPERATIONS --------

  Canvas clone();

  // These functions change the pixels of the canvas in place, as opposed to scale, rotate, etc
  // which only set the current transformation matrix that affects future drawing operations.
  // This can be a little confusing, but scale, rotate, etc... come from HTML canvas, where they are defined that way.

  // This method ignores the state of the canvas.
  void crop(int x, int y, int width, int height);
 
  // This method ignores the state of the canvas.
  // Note: resizes the image, not the canvas -- uses interpolation to generate new pixels.
  void resize(int width, int height);

  // add delta to each color channel.
  // Color channel values are expressed as floats between 0.0 and 1.0, and delta should be between -1.0 and 1.0.
  // delta = -1.0 => fully black image, 0.0 => original image, 1.0 => fully white image.
  // Expressing delta as a float between -1.0 and 1.0 makes it independent of color depth -- a given delta increases
  // brightness by a certain amount irrespective of color depth.
  void adjustBrightness(float delta);

  void adjustContrast(float contrast);

  // 0.0 => grayscale, 1.0 => original image.
  void adjustSaturation(float saturation);
 
  void adjustHue(float angle); // angle by which to rotate on the color wheel.

  void blur(float factor, int radius);
  coid sharpen(float factor, int radius);


  // ----- THE FOLLOWING ARE FROM HTML CANVAS -------
  // Please see the canvas spec at  http://www.whatwg.org/specs/web-apps/current-work/#canvas

  // back-reference to the canvas:
  readonly attribute Canvas canvas;

  // (default 1.0)
  attribute float globalAlpha; 
  // we only support source-over and copy. default source-over
  attribute DOMString globalCompositeOperation; 

  // note: must be a color, not a gradient or pattern; we don't support those.
  attribute string fillStyle; 
  
  // saves current state on stack.
  void save();
  // pops a state object from the stack and sets the current state to that state.
  void restore(); 
 
  // Note that our notion of state is different from Canvas's. Our state consists of:
  // globalAlpha, globalCompositeOperation, fillStyle and the current transformation matrix (and the clip region, once we add support for that).
  // HTML Canvas supports a richer state (see http://www.whatwg.org/specs/web-apps/current-work/#the-canvas0);
  // we don't suppport these additional attributes.

  // drawing images and canvii
  void drawImage(HTMLCanvasElement image, int dx, int dy);
  void drawImage(HTMLCanvasElement image, int dx, int dy, int dw, int dh);
  void drawImage(HTMLCanvasElement image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);  
  void drawImage(HTMLImageElement image, int dx, int dy);
  void drawImage(HTMLImageElement image, int dx, int dy, int dw, int dh);
  void drawImage(HTMLImageElement image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);  

  // drawing rectangles
  void clearRect(int x, int y, int w, int h);
  // see fillStyle.
  void fillRect(int x, int y, int w, int h); 
  // does not support stroke styles; draws a one-pixel border.  
  void strokeRect(int x, int y, int w, int h);
  
  // affine transformations (default transform is the identity matrix)
  void scale(float x, float y);
  void rotate(float angle);
  void translate(float x, float y);
  void transform(float m11, float m12, float m21, float m22, float dx, float dy);
  void setTransform(float m11, float m12, float m21, float m22, float dx, float dy);
  // convenience function
  void resetTransform(); 

  ImageData createImageData(int sw, int sh);
  ImageData getImageData(int sx, int sy, int sw, int sh);
  void putImageData(ImageData imagedata, int dx, int dy);
  void putImageData(ImageData imagedata, int dx, int dy, int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight);
};
}}}

*_ImageData class:_*
{{{
ImageData class {
  readonly attribute long int width;
  readonly attribute long int height;
  readonly attribute int[] data;
};
}}}
= Deviation from HTML5 =
  *  Added Text support (for annotation support)
  * Added primitives for color transformation, convolution and lookup tables.
  * Drawing of arbitrary paths not supported yet.
  * No support for clipping regions, gradients, patterns, shadows, strokes and line styles.

= Sample Code =
*_Example 1: Downloads an image from a server, crops and resizes it, displays the result and uploads it_*:
{{{
var request = google.gears.factory.create('httprequest');
var serverUrl = 'http://picasaweb.google.com/photo/23432094834';
request.open('GET', serverUrl);
request.onreadystatechange = function() {
  if (request.readyState == 4) {
    process(request.responseBlob);
  }
};
request.send();

function process(var srcBlob) {
  var canvas = google.gears.factory.create('canvas');
  canvas.load(srcBlob);

  var context = canvas.getContext('2d');
  // crop out 10 pixels on each side.
  context.crop(10, 10, canvas.width - 20, canvas.height - 20);
  context.resize(1024, 768);

  var destBlob = canvas.toBlob();

  // update on screen:
  var localServer = google.gears.factory.create('localserver');
  var store = localServer.createStore(STORE_NAME);
  store.captureBlob(destBlob, IMAGE_URL);
  var img = document.getElementById('myImage');
  img.src = IMAGE_URL;

  // now upload to server:
  request = google.gears.factory.create('httprequest');
  request.open('PUT', serverUrl);
  request.onreadystatechange = function() {
  if (request.readyState == 4) {
    alert('Upload finished!');
  }
  request.sendBlob(destBlob);
};
}}}

*_Example 2: Performs some more image operations and draws text_*:
{{{
// load the image as above.

function process(var srcBlob) {
  var canvas = google.gears.factory.create('canvas');
  canvas.load(srcBlob);
  
  var context = canvas.getContext('2d);
  context.crop(10, 10, canvas.width - 20, canvas.height - 20); 
  context.resize(1024, 768);

  // rotate the image:
  var destCanvas = google.gears.factory.create('canvas');
  var destContext = destCanvas.getContext('2d');

  // NOTE: does not rotate the image in place;
  // instead sets the current transformation matrix for future draw operations.
  // This is how Canvas works.
  destContext.rotate(0.2);

  destContext.draw(canvas);
  destContext.resetTransform();
  destContext.adjustBrightness(0.2);
  destContext.drawText(950, 100, 'The quick brown fox jumped over the lazy dog', 'Times New Roman', 14, {
      'bold': true,
      'italics': true,
      'wrap': true });

  var destBlob = destCanvas.toBlob("image/jpeg", {
      'interlaced': true,
      'colorMode': 16,
      'compressionFactor':0.7});

  // display and upload the output blob as in the previous example.
}
}}}

= Points to ponder =

*_Undo_*:

This is one possible way in which we can implement undo. 

Many operations normally modify the canvas in place, but take an optional switch that makes them return a new canvas instead. The advantage with this approach is flexibility -- if you're interested in the previous state of the canvas (for undo), you generate the output in a new canvas without having to do a potentially expensive clone operation. On the other hand, if don't care about undo, you can overwrite the source in place without paying the memory cost of a second buffer (for many operations).

The problem with this approach is that for consistency the draw functions should also have an option to return a new canvas, and such a thing may be tougher to merge into the HTML standard. So right now, we don't support this. If you want to preserve the old state, you have to either clone the canvas after each operation or keep track of the initial state and the list of operations applied on it, so that you can undo to any point by applying some of the operations.

We can re-examine the problem for v2 if one of our clients wants to use it. 

= Beyond V1 =
*_Updates to CanvasRenderingContext2D class:_*
{{{
  // each lookup table is an array of color channel values specified as floats between 0.0 and 1.0.
  // For each pixel, the input color channel value is used as
  // an index into the lookup table to give the output color channel value which is converted back
  // into the appropriate format for the canvas's color model.
  // If a table is not of the correct size for the color model, we interpolate and convert it.
  // Any argument can be 'undefined', in which case that color channel is left untouched.
  // Specifying the elements of the lookup table as floats makes it independent of the color model.
  // TODO: not sure whether to use channel-wise lookup tables or mappings between RGB triplets. That is,
  // do we map R, G and B components of a color separately or the whole color at once?
  void colorLookupTable(optional float[] redLookupTable,
                        optional float[] blueLookupTable,
                        optional float[] greenLookupTable);

  // assign undefined to set the clip region to the whole canvas.
  // may be arbitrarily shaped, in general, not necessarily rectangular.
  // once clipRegion is added, it will be part of the state, and drawing operations and various image operations
  // (color matrix, median filter, ...) will respect the clip region.
  attribute ClipRegion clipRegion; 

  // returns the new clip region; does not set it as the current clip region.
  ClipRegion defineRectangularClipRegion(int x, int y, int width, int height);

  // copies the pixels selected in this clip region to a new canvas and returns it.
  // The returned canvas is the smallest rectangle that can hold all selected pixels.
  // Since the clip region may be non-rectangular, unselected pixels may be present in the
  // returned canvas, but with alpha = 0.
  Canvas getPixels(ClipRegion clipRegion);
};
}}}

*_Clip Region:_*
{{{
class ClipRegion {
  void add(ClipRegion other);
  void subtract(ClipRegion other);
  void invert();

  ClipRegion clone();
};
}}}

*_Cool photo manipulation stuff:_*
{{{
class PhotoUtils { 
 // some high-level operations.

 // threshold is between 0.0 and 1.0. Describes how much a pixel's red component
 // should exceed its green and blue components
 // for it to be considered part of the red eye and processed. TODO: define this precisely.
  void redEyeFilter(Canvas canvas, int centerX, int centerY, float threshold);

  // need to define this better
  void autoColorCorrection(Canvas canvas);

  // selects pixels around the origin whose colors are close enough to the origin pixel's.
  // The selected region may be non-rectangular.
  // tolerance is betwen 0.0 (select only pixels with exactly the same color) and 1.0 (select all pixels)
  ClipRegion magicWand(Canvas canvas, int originX, int originY, float tolerance);
};
}}}
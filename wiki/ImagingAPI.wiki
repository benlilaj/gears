#summary Off-screen photo manipulation

= Introduction =
The purpose of this module is to provide programmatic support for off-screen photo manipulation on the browser.

= Requirements =
  #  V1 features (Basic):
    * Basic operations (crop, resize, scale, rotate)
    * Primitives (affine transforms, color transforms, convolution matrices, lookup tables)
    * Draw image onto canvas from local file / remote URL
    * Save image (after manipulation) onto local file / post it to a remote URL (We get this functionality by virtue of using the Blob abstraction)
    * Integration with Gears Blob and URL capture
    * Support for BMP, PNG and JPEG formats
    * Annotation (support for basic text)
  # Beyond V1 (Advanced):
    * Rendering on screen (real-time as opposed to via the BMP encoded capture URL through HTTP)
    * Clippings of arbitrary shape
    * Drawing primitives
    * Cool Photo stuff (Red-eye removal, smart scissors, magic wand, etc...)
    * Support other color depths (<>32 bpp)
    * Better support for non-destructive edits

= JS interface =
We model the API based on the _HTML5CanvasElement_ in the HTML5 spec. Please refer to http://www.whatwg.org/specs/web-apps/current-work/#canvas for details.

*_Canvas class:_*
{{{
Canvas class
{  
  // Exports this canvas as a blob. This is a snapshot; updates to the canvas are not reflected in the blob.
  // Supported formats: JPEG, PNG, BMP
  // 'attributes' is a map of key-value pairs. 
  // These are the available keys, all optional:
  //      indexed -- boolean. defaults to false unless palette is specified.
  //      palette -- an array of colors (as integer values). Explicitly specifying indexed = false while passing in a palette is an error.
  //      compressionQuality -- float between 0.0 (small size) and 1.0 (good quality). only for JPEG.
  //      interlaced -- boolean.
  Blob toBlob(optional String mimeType, optional Map attributes);

  Canvas clone();

  // the palette of the image, if the canvas was load()ed from an indexed mode image.
  // Note that on load, the image is converted to RGB; the palette is preserved in case you want
  // to export the image back to indexed mode, but the canvas itself doesn't have an indexed mode.
  readonly attribute palette;

  // COMMON WITH HTML CANVAS
  attribute unsigned long width;
  attribute unsigned long height;

  // returns a Gears object (not really a DOMObject), (only CanvasRenderingContext2D is supported currently, and this object is got when contextId is passed as '2d').
  DOMObject getContext(DOMString contextId);
};
}}}

*_CanvasRenderingContext2D class:_*

Our state is a subset of HTML5 Canvas's. Our state consists of:
  * The current transformation matrix
  * The current clipping region (once we add support for this after V1)
  * globalAlpha, globalCompositeOperation and fillStyle. HTML Canvas supports a richer state with more attributes pertaining to drawing that we don't support. See the spec. for details.

The 'transform' function just sets the current transformation matrix and does not apply it on the underlying image on the canvas. Just as with HTML Canvas, the drawing functions (drawImage, clearRect, fillRect, strokeRect below) respect the state, and apply the necessary transforms on the clipping region. However color transforms, convolution transforms, etc... are not part of the state, and invocations of these functions apply the changes on the underlying image directly. Hence, functions such as 'crop', 'resize', etc... apply the changes right then, whereas 'scale', 'rotate', etc... just update the state (the transformation matrix to be precise) and the operations are applied only when a draw function is called.

{{{
CanvasRenderingContext2D class
{
  // ----- THE FOLLOWING ARE FROM HTML CANVAS -------
  // Please see the canvas spec at http://www.whatwg.org/specs/web-apps/current-work/#canvas

  // back-reference to the canvas:
  readonly attribute Canvas canvas;

  // (default 1.0)
  attribute float globalAlpha; 
  // we only support source-over and copy. default source-over
  attribute DOMString globalCompositeOperation; 

  // note: must be a color, not a gradient or pattern; we don't support those.
  attribute string fillStyle; 
  
  // saves current state on stack.
  void save();
  // pops a state object from the stack and sets the current state to that state.
  void restore(); 
 
  // drawing images and canvii
  void drawImage(HTMLCanvasElement image, int dx, int dy);
  void drawImage(HTMLCanvasElement image, int dx, int dy, int dw, int dh);
  void drawImage(HTMLCanvasElement image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);  
  void drawImage(HTMLImageElement image, int dx, int dy);
  void drawImage(HTMLImageElement image, int dx, int dy, int dw, int dh);
  void drawImage(HTMLImageElement image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);  

  // drawing rectangles
  void clearRect(int x, int y, int w, int h);
  // see fillStyle.
  void fillRect(int x, int y, int w, int h); 
  // does not support stroke styles; draws a one-pixel border.  
  void strokeRect(int x, int y, int w, int h);
  
  // affine transformations (default transform is the identity matrix)
  void scale(float x, float y);
  void rotate(float angle);
  void translate(float x, float y);
  void transform(float m11, float m12, float m21, float m22, float dx, float dy);
  void setTransform(float m11, float m12, float m21, float m22, float dx, float dy);

  ImageData createImageData(int sw, int sh);
  ImageData getImageData(int sx, int sy, int sw, int sh);
  void putImageData(ImageData imagedata, int dx, int dy);
  void putImageData(ImageData imagedata, int dx, int dy, int dirtyX, int dirtyY, int dirtyWidth, int dirtyHeight);

  // -------- THE FOLLOWING ARE ADDITIONAL ABSTRACTIONS WE SUPPORT ------------

  // 4x5 matrix for RGBA images and 3x4 for RGB.
  // TODO: Or is it better to take 4x5 consistently and ignore the alpha row and column if the image is RGB?
  // Please refer to http://www.adobe.com/devnet/flash/articles/matrix_transformations_04.html
  void colorTransform(float[] colorMatrix);
 
  // Please refer to http://www.adobe.com/devnet/flash/articles/matrix_transformations_05.html
  void convolutionTransform(float[] convolutionMatrix);
 
  void medianFilter(float radius);
 
  // For annotation support
  // x, y, width, height identify a bounding box into which the text is drawn. 
  // If width and height are not specified, the bounding box extends to the last row or column of the canvas.
  // attributes can have the following keys:
  //   center: boolean, centers the text within the bounding box, as opposed to left align (default).
  //   bold: boolean
  //   italic: boolean
  //   underline: boolean
  //   wrap: boolean, specifies that at the right edge of the bounding box, text is wrapped to the next line instead of truncating it (default).
  //   singleLine: treat newlines and tab characters as single spaces,
  //     thus forcing the output to one line. Defaults to false. Cannot be used along with wrap.
  // Need to guarantee consistent rendering across all platforms. We're thinking of using FreeType.
  void drawText(String text, String font, int size, int x, int y, optional int width, optional int height, optional object attributes);

  // Throws away the existing contents of the canvas.
  // Sets the canvas's dimensions to those of the image in the blob.
  void load(Blob blob);

  void drawImage(Canvas image, int dx, int dy);
  void drawImage(Canvas image, int dx, int dy, int dw, int dh);
  void drawImage(Canvas image, int sx, int sy, int sw, int sh, int dx, int dy, int dw, int dh);
 
  // similar to putImageData except that it respects the current state.
  // Useful for drawing custom shapes into an ImageData and then compositing that into the canvas.
  void drawImageData(ImageData imagedata, int sx, int sy, int sw, int sh, int dx, int dy);


  // ----- CONVENIENCE FUNCTIONS FOR COMMON OPERATIONS --------
  // might build on top of one or more abstractions listed above.

  // The below functions change the pixels of the canvas in place, as opposed to scale, rotate, etc...
  // which only set the current transformation matrix that affects future drawing operations.

  // This method ignores the state of the canvas.
  void crop(int x, int y, int width, int height);
 
  // This method ignores the state of the canvas.
  // Note: resizes the image, not the canvas -- uses interpolation to generate new pixels.
  void resize(int width, int height);

  // add delta to each color channel.
  // Color channel values are expressed as floats between 0.0 and 1.0, and delta should be between -1.0 and 1.0.
  // delta = -1.0 => fully black image, 0.0 => original image, 1.0 => fully white image.
  // Expressing delta as a float between -1.0 and 1.0 makes it independent of color depth -- a given delta increases
  // brightness by a certain amount irrespective of color depth.
  void adjustBrightness(float delta);

  void adjustContrast(float contrast);

  // 0.0 => grayscale, 1.0 => original image.
  void adjustSaturation(float saturation);
 
  void adjustHue(float angle); // angle by which to rotate on the color wheel.

  void blur(float factor, int radius);
  void sharpen(float factor, int radius);
  // convenience function
  void resetTransform(); 
};
}}}

*_ImageData class:_*
{{{
ImageData class {
  readonly attribute long int width;
  readonly attribute long int height;
  readonly attribute int[] data;
};
}}}

= Deviation from HTML5 =
  *  Added Text support (for annotation support)
  * Added primitives for color transformation, convolution and lookup tables.
  * Drawing of arbitrary paths not supported yet.
  * No support for clipping regions, gradients, patterns, shadows, strokes and line styles.
  * We do not support export to data URLs because the image data can be huge plus there is a need to UUencode it. We have an alternate approach supporting a HTTP URL capture, and hence this is not a limitation.

= Sample Code =
*_Example 1: Downloads an image from a server, crops and resizes it, displays the result and uploads it_*:
{{{
var request = google.gears.factory.create('httprequest');
var serverUrl = 'http://picasaweb.google.com/photo/23432094834';
request.open('GET', serverUrl);
request.onreadystatechange = function() {
  if (request.readyState == 4) {
    process(request.responseBlob);
  }
};
request.send();

function process(var srcBlob) {
  var canvas = google.gears.factory.create('canvas');
  canvas.load(srcBlob);

  var context = canvas.getContext('2d');
  // crop out 10 pixels on each side.
  context.crop(10, 10, canvas.width - 20, canvas.height - 20);
  context.resize(1024, 768);

  var destBlob = canvas.toBlob();

  // update on screen:
  var localServer = google.gears.factory.create('localserver');
  var store = localServer.createStore(STORE_NAME);
  store.captureBlob(destBlob, IMAGE_URL);
  var img = document.getElementById('myImage');
  img.src = IMAGE_URL;

  // now upload to server:
  request = google.gears.factory.create('httprequest');
  request.open('PUT', serverUrl);
  request.onreadystatechange = function() {
  if (request.readyState == 4) {
    alert('Upload finished!');
  }
  request.sendBlob(destBlob);
};
}}}

*_Example 2: Performs some more image operations and draws text_*:
{{{
// load the image as above.

function process(var srcBlob) {
  var canvas = google.gears.factory.create('canvas');
  canvas.load(srcBlob);
  
  var context = canvas.getContext('2d');
  context.crop(10, 10, canvas.width - 20, canvas.height - 20); 
  context.resize(1024, 768);

  // rotate the image:
  var destCanvas = google.gears.factory.create('canvas');
  var destContext = destCanvas.getContext('2d');

  // NOTE: does not rotate the image in place;
  // instead sets the current transformation matrix for future draw operations.
  // This is how Canvas works.
  destContext.rotate(0.2);

  destContext.draw(canvas);
  destContext.resetTransform();
  destContext.adjustBrightness(0.2);
  destContext.drawText(950, 100, 'The quick brown fox jumped over the lazy dog', 'Times New Roman', 14, {
      'bold': true,
      'italics': true,
      'wrap': true });

  var destBlob = destCanvas.toBlob("image/jpeg", {
      'interlaced': true,
      'colorMode': 16,
      'compressionQuality':0.7});

  // display and upload the output blob as in the previous example.
}
}}}

= Points to ponder =

*_Undo_*:

Right now the way an undo can be implemented using the above API is to either clone the canvas after each operation or keep track of the initial state and the list of operations applied on it, so that one can undo to any point by applying some of the operations.

= Beyond V1 =
*_Updates to CanvasRenderingContext2D class:_*
{{{
  // ----- NEW ABSTRACTION ------------
  // each lookup table is an array of color channel values specified as floats between 0.0 and 1.0.
  // For each pixel, the input color channel value is used as
  // an index into the lookup table to give the output color channel value which is converted back
  // into the appropriate format for the canvas's color model.
  // If a table is not of the correct size for the color model, we interpolate and convert it.
  // Any argument can be 'undefined', in which case that color channel is left untouched.
  // Specifying the elements of the lookup table as floats makes it independent of the color model.
  // TODO: not sure whether to use channel-wise lookup tables or mappings between RGB triplets. That is,
  // do we map R, G and B components of a color separately or the whole color at once?
  void colorLookupTable(optional float[] redLookupTable,
                        optional float[] blueLookupTable,
                        optional float[] greenLookupTable);

  // ------ CLIP REGION SUPPORT (FROM HTML5) ---------
  // assign undefined to set the clip region to the whole canvas.
  // may be arbitrarily shaped, in general, not necessarily rectangular.
  // once clipRegion is added, it will be part of the state, and drawing operations and various image operations
  // (color matrix, median filter, ...) will respect the clip region.
  attribute ClipRegion clipRegion; 

  // returns the new clip region; does not set it as the current clip region.
  ClipRegion defineRectangularClipRegion(int x, int y, int width, int height);

  // copies the pixels selected in this clip region to a new canvas and returns it.
  // The returned canvas is the smallest rectangle that can hold all selected pixels.
  // Since the clip region may be non-rectangular, unselected pixels may be present in the
  // returned canvas, but with alpha = 0.
  Canvas getPixels(ClipRegion clipRegion);
};
}}}

*_Clip Region:_*
{{{
// ----- FROM HTML5 --------
class ClipRegion {
  void add(ClipRegion other);
  void subtract(ClipRegion other);
  void invert();

  ClipRegion clone();
};
}}}

*_Cool photo manipulation stuff:_*
{{{
class PhotoUtils { 
 // some high-level operations.

 // threshold is between 0.0 and 1.0. Describes how much a pixel's red component
 // should exceed its green and blue components
 // for it to be considered part of the red eye and processed. TODO: define this precisely.
  void redEyeFilter(Canvas canvas, int centerX, int centerY, float threshold);

  // need to define this better
  void autoColorCorrection(Canvas canvas);

  // selects pixels around the origin whose colors are close enough to the origin pixel's.
  // The selected region may be non-rectangular.
  // tolerance is betwen 0.0 (select only pixels with exactly the same color) and 1.0 (select all pixels)
  ClipRegion magicWand(Canvas canvas, int originX, int originY, float tolerance);
};
}}}
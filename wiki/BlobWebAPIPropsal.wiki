#summary A Web API working group proposal for blobs

= Problem =

Web applications have no way to interact with binary data. For example, it is not possible to get the binary response of an XMLHttpRequest or a file selected from a file upload control.

= Considerations =

  1. There are many potential provides and consumers of binary data in a web application. For example, network connections, file upload controls, audio/video, cameras, and any sort of resource could all naturally be extended with APIs to accept and provide binary data. 
  1. We must not violate the existing user understanding of web application security. For example, current web applications never ask for permission to write to your filesystem.

= Solution =

We propose the addition of a Blob interface to serve as a way to exchange binary data between producers and consumers. Blobs are complementary to ECMAScript-style ByteArrays and other in-memory representations of data. The primary difference is that Blobs are immutable, and can therefore represent large objects.

Having a common object to represent potentially large binary between APIs provides a lot of power and flexibilty without a lot of API. For example:

  * Get a blob from a large file, chop it up into smaller blobs, and upload the pieces using XMLHttpRequest to get a large file uploader.
  * Get a blob from a file while offline, store it in the database or application cache, and upload it later when connected.
  * Get a blob from the network, send it into canvas, then get the modifications back out and re-upload them.
  * Etc...

= The Blob Interface =

{{{
interface Blob {
  readonly attribute int64 length;
  Blob slice(int64 start, int64 length);

  void readAsText(ReadStreamSuccessCallback<string> onsuccess,
      ReadStreamFailureCallback on fail, optional string encoding,
      optional int64 start, optional int64 length);
  void readAsBase64(ReadStreamSuccessCallback<string> onsuccess,
      ReadStreamFailureCallback onfail, optional int64 start, optional int64 length);
  void readAsBytes(ReadStreamSuccessCallback<ByteArray> onsuccess,
      ReadStreamFailureCaallback onfail, optional int64 start,
      optional int64 length);
  void readAsByteString(ReadStreamSuccessCallback<string> onsuccess,
      ReadStreamFailureCallback onfail, optional int64 start,
      optional int64 length);
}
void ReadStreamSuccessCallback<T>(T data); // assumes T has a "length" property.
void ReadStreamFailureCallback(Error e); // e contains some sort of data about
                                         // what went wrong.
}}}

*Note:* Although it is impossible to guarantee that the data backing a blob does not ever change, this proposal assumes that such changes are rare and accidental. The UA should attempt to detect such situations and call ReadStreamFailureCallback with an error code that lets the application try again.


= Getting Blobs from Local Files =

The current `<input type="file">` element can be extended to allow access to blobs representing the file (or files with WebForms extensions) that the user has chosen. 

We propose the following extension to HTMLFileInputElement interface:

{{{
interface HTMLFileInputElement {
  readonly FileList files;
};

interface FileList {
  readonly int length;
  File item(int index);
};

interface File {
  readonly string name; // only the name portion, not the path (for privacy)
  readonly Blob contents;
};
}}}


= Blobs + XHR, Sitting in a Tree =

It is useful to be able to send and receive blobs using XHR. Using FilePicker, Blob, and XHR, one could build a very nice large file uploader for a site like Flickr or YouTube.

{{{
interface XMLHttpRequest {
  readonly Blob responseBlob;
  void send(Blob data); // overloads the existing send methods
};
}}}


= Exporting Blobs to Files =

It is currently possible to prompt a user to save a server-generated files using window.open() and special headers. It would be useful to be able to do the same thing using client-generated blobs. This could be achieved by extending the Window object.

{{{
interface Window {
  // prompts the user to save the file to disk.
  void exportBlobToFile(Blob blob);
};
}}}


= Etcetera =

Blob support can be added to many existing and proposed APIs, including `<canvas>`, `<audio>`, `<video>`, `<img>`, `Database`, `Offline Applications`, etc.


= Appendix: Alternate File Picker !API =

Instead of extending the existing `<input type="file">` element, we also considered designing an entirely new _FileSystem_ interface for selecting files, exporting files, and potentially other operations in the future.

This solution is elegant because all the file-related APIs can be together, and some additional flexibility is granted by having a purely programmatic interface.

It also has the advantage that it would finally allow web developers to style their "Browse..." buttons as they please. 
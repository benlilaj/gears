#summary Secure client file access
#labels DesignDoc

==Introduction==

The purpose of this module is to provide secure access to files on the client machine. The  FileSystem module has now been merged with the Desktop module. Therefore this document describes the FileSystem functionality in the Desktop module.


==Features==

  * Multiple files can be provided by the user.
    * The API then provides access to these files. 
  * Once the files are available, potential processing options are:
    * Compress files.
    * Send files to a server.
    * Capture files to the local resource store.


==Security==

  * Access to the user's file system can only be granted by the user.
    * The permission is granted via the use of a file picker dialog. 
  * A malicious application will NOT be able to access arbitrary files on the user's system.
    * Do not allow random access to the user's file system.
      * filesystem.open('/etc/shadow'); 
    * Do not allow access above the specified location in the user's file system.
      * filesystem.changedir('../../etc/shadow');
  * Do not allow a malicious application to display a dialog when the browser window or tab is inactive. A window is considered active when it has foreground focus (the window or tab is currently selected).


==Use cases==

Name: input files

Description: a user provides details of files to make available for further processing

Author: Chris De Vries

Date: 11/01/2008

Steps:
  # The user indicates files they wish to make available to the system.
  # The files are made available for iteration via the API.


==JavaScript Interfaces==

{{{
// A simple file handle
interface File {
  // The full name of the file.
  readonly attribute string name;

  // A blob representing the contents of this file.
  readonly attribute Blob blob;
}

interface Desktop {
  // Other Desktop functions here...


  // Open multiple files. Displays a file picker dialog to user.
  // Returns: an Array of File OR an empty Array if the user canceled the selection
  // Parameters:
  //     filters [optional] - An array consisting of pairs of strings. The length must be a factor of two.
  //        The first string is a description of the filter.
  //        The second string is a semi-colon separated list of filters.
  //        Example. ['Image Files (*.gif, *.jpg, *.png)', '*.gif;*.jpg;*.png',
  //                  'Video Files (*.avi, *.mpg, *.mov)', '*.avi;*.mpg;*.mov',
  //                  'All Files (*.*)', '*.*']
  //
  Array openFileDialog([in string Array filters]);
}
}}}


==C++ Internal Interfaces==

{{{
// This enum will allow for different dialogs in the future.
// An example would be FILES_AND_DIRECTORIES.
enum FileDialogMode {
  FILE_DIALOG_MULTIPLE_FILES  // one or more files
};

// Constructs a file dialog according to mode.
// Caller is responsible for freeing the returned memory.
// Returns: null pointer on failure
// Parameters:
//   mode - in - the type of dialog to construct
FileDialog* NewFileDialog(FileDialogMode mode);

// This interface will be implemented for every supported operating system.
class FileDialog {
  // Displays a file dialog.
  // Returns: false on invalid input or failure
  // Parameters:
  //   filter - in, optional - An array consisting of pairs of strings.
  //     Every first string is a description of a filter.
  //     Every second string is a semi-colon separated list of filters.
  //     Example "Images" and "*.jpg;*.gif;*.png".
  //
  //   files - out - An array of files selected by the user.
  //     If the user canceled the dialog this will be an empty array.
  //     A new array is constructed and placed here.
  //     Caller is responsible for freeing returned memory.
  //
  //   error - out - The error message if the function returned false.
  //
  virtual bool OpenDialog(const JsArray* filters,
                          JsArray** files,
                          std::string16* error) = 0;
}
}}}


==Code Example==

{{{
// HTML
function insertRow(message) {
  var row = document.getElementById('output').insertRow(-1);
  row.insertCell(0).innerHTML = message;  // insertCell arg is column position
}


// FileSystem
function task(fn) {
  if (fn()) {
    setTimeout(function() { task(fn); }, 0);
  }
}

function createPrintFunction(files) {
  var fileArray = files;
  var index = 0;
  return (function() {
    if (index < files.length) {
      var file = fileArray[index];
      var name = file.name;
      insertRow(name + '<br>' + '<img src="' + name + '"></img> <br>');
      index++;
      return true;
    }
    return false;
  });
}

function openDialog() {
  try {
    var desktop = google.gears.factory.create('beta.desktop');
    var files = desktop.openFileDialog(['Images (*.jpg, *.gif)', '*.jpg;*.gif', 'All files (*.*)', '*.*']);
    if (files) {
      task(createPrintFunction(files));
    }
  } catch(ex) {
    alert(String(ex));
  }
}
}}}
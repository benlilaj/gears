#summary A proposal to add native HTML5 SQL API to Gears
#labels DesignDoc,WorkInProgress

Work in progress
----

= Introduction =

This proposal aims to implement a Gears module based on the existing specification, [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML5 Storage API]. This specification is currently implemented in the [http://trac.webkit.org/projects/webkit/browser/trunk/WebCore/storage WebKit trunk]. There is also an incomplete [http://attic.glazkov.com/player/ player] implementation, written in Javascript as a Gears worker.

=Goals=

The goals of the proposal are:
 * Enable !JavaScript developers to easily write code that works with both Gears and browser database APIs.
 * Reduce developer "mind-print" by implementing the same API that is available in browsers.
 * Support the proposed HTML5 database standard with an implementation available for all browsers that Gears supports.
 * Implement an asynchronous API that can be called from the UI thread without freezing the UI.
 * Implement a synchronous API to simplify usage inside workers.

Minor/bonus goals:
 * implement a thread pool abstraction that can be used in other modules for asynchronous operations
 * build a new module from scratch using the new Dispatcher model.

Non-goals:
  * Allow current gears databases to work with database2
  * Allow access to database2 from the DOM window object (callers will access database2 through the Gears factory, just like any other Gears object).
  * Allow access to any native browser implementation of HTML5 databases


=Javascript Interface=

The standard interface is defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML 5 specification]. Gears makes some additions for compatibility with native implementations and to add synchronous DB access.


== !DatabaseManager ==

The database manager is the top-level entrypoint to the database2 API in Gears. Callers create instances of it using:

{{{
  google.gears.factory.create('beta.databasemanager');
}}}

!DatabaseManager takes the place of `window.openDatabase()` in the HTML5 spec. Using a different top-level entrypoint allows us to coexist with native browser implementations of the HTML5 database API.

{{{
interface DatabaseManager {
  Database2 openDatabase(in DOMString name,
                         in DOMString version, 
                         in DOMString displayName,
                         in unsigned long estimatedSize);
  // Future: add removeDatabase(), listDatabases()
}
}}}


== Database2 ==

Instances of Database2 are returned by `DatabaseManager.openDatabase()`. Database2 implements the Database interface, as defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#database0 HTML5]. It also implements the following extensions, which allow synchronous Database access:

{{{
interface Database2 {
  void synchronousTransaction(SQLSynchronousTransactionCallback callback)
      throws SQLError;
}

interface SQLSynchronousTransactionCallback {
  void handleEvent(in SQLSynchronousTransaction transaction);
}

interface SQLSynchronousTransaction {
  SQLResultSet executeSql(in DOMString sqlStatement, in ObjectArray arguments)
      throws SQLError;
}
}}}


=Differences from the existing Gears database module=

The API approach differs significantly from the current Gears Database module by introducing an explicit [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqltransaction SQLTransaction] interface. In fact, creating single, transactionless statements is not possible using this API. As a benefit, the management of transactions is completely abstracted out (`BEGIN`, `COMMIT`, `ROLLBACK`, etc. are prohibited in statements).

Because the API is asynchronous, the [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultset SQLResultSet] is an offline dataset, unlike the one in Database. The user accesses row data using an Object, with each field is mapped is a property (see [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultsetrowlist SQLResultSetRowList]).

Additionally, the API includes explicit database version management features in the form of [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#changeversion changeVersion] and an [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#opendatabase openDatabase] version parameter.

There are two types of error callbacks specified, one for transaction, and one for statement. Essentially, the statement error callbacks are used to detect statement sanitizing/execution failures, and the transaction error callbacks are responsible for handling versioning, transaction, and general statement failures.

Unlike the Database module, the spec prescribes limiting available storage for each database.


=Code Example=

{{{
var dbman = goolge.gears.factory.create('beta.databasemanager');
var db = dbman.open('pages', '0.0.1.0',
  'Collection of crawled pages', 3000000);

function renderPageRow(row) {
  // insert page row into a table
}

function reportError(source, message) {
  // report an error
}

function renderPages() {
  db.transaction(function(tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS Pages(title TEXT, lastUpdated INTEGER)', 
      []);
    tx.executeSql('SELECT * FROM Pages', [], function(rs) {
      for(var i = 0; i < rs.rows.length; i++) {
        renderPageRow(rs.rows.item(i));
      }
    })
  })  
}

function insertPage(text, lastUpdated) {
  db.transaction(function(tx) {
    tx.executeSql('INSERT INTO Pages VALUES(?, ?)', [ text, lastUpdated ],
      function() {
        // no result returned, stub success callback
      },
      function(tx, error) {
        reportError('sql', error.message);
      });
  })
}
}}}

There is also a [http://webkit.org/misc/DatabaseExample.html working example] (requires [http://nightly.webkit.org/ WebKit nightly]) on webkit.org


=Technical Design=

== Class Sketch ==

{{{
// Encapsulates a sqlite3 handle so that it can be initialized lazily and
// refcounted.
class Database2Connection : RefCounted {
 public:
  ~Database2Connection() {
    // free handle
  }

  bool Init() {
    // init handle if not already
  }

  sqlite3 *handle() const;

 private:
  sqlite3 *handle_;
};


// Allows JavaScript to create database objects. Could be extended
// in the future with removeDatabase() and listDatabases().
class Database2Manager : ModuleImplBaseClassVirtual {
 public:
  // IN: string name, string version, string displayName, int estimatedSize)
  // OUT: Database2
  void OpenDatabase(JsCallContext *cx) {
  // create a Database2 instance and pass name and version into it
  // displayName and estimatedSize not used by Gears
  }
};


// Implements the HTML5 database interface, which allows the creation
// of transactions. We also have our own proprietary
// synchronousTransaction() method. This class also has a reference
// to a DatabaseConnection object which it shares with all transactions
// it creates.
class Database2 : ModuleImplBaseClassVirtual {
 public:
  // IN: function start_callback, function success_callback, function failure_callback)
  // OUT: void
  void Transaction(JsCallContext *cx) {
    Database2Transaction *tx = CreateModule<Database2Transaction>();
    tx->StartAsync(connection);
  }
  
  // IN: function start_callback
  // OUT: void
  void SynchronousTransaction(JsCallContext *cx) {
    Database2Transaction *tx = CreateModule<Database2Transaction>();
  
    if (!tx->StartSync(connection)) {
      // could be because:
      // - there was already a transaction open
      // - opening the transaction failed
      // - any of the statements failed
      // - any of the callback threw an exception
      // - the commit failed
      // if there isn't already an exception set (cx->is_exception_set()), create
      // one using the error.
    }
  }
  
  // IN: string old version, string new version, optional function callback,
  //     optional function success, optional function failure
  // OUT: void
  void ChangeVersion(JsCallContext *cx) {
    // TODO(dimitri)
  }
  
 private:
  // Shared reference to the connection used by all transactions from this
  // database instance. This is initialized during the first transaction.
  scoped_refptr<DatabaseConnection> connection;
};



// Here be the meat. Transaction implements the HTML5 SQLTransaction
// interface and contains the code to actually execute a transaction.
//
// The general idea for async transactions is that there is a background and
// foreground thread. The foreground thread is the thread of execution when
// StartAsync() is called. We handwave and say we will somehow obtain a
// background thread, but the exact policy is left to some other component
// (it could be that there is just one thread per origin, or there could be some
// limit, or it could be a fancier pool where threads are reused).
//
// Messages are posted from the foreground thread to the background thread to
// begin a transaction and for each statement. The background thread receives
// the message and does any appropriate processing, then posts a message back
// to the foreground thread to invoke js callbacks. The background thread then
// blocks and waits for the js callbacks to complete, then handles the results
// from the callback. It's important to block while waiting for js callbacks
// because the spec allows for statement failure callbacks to cancel a ROLLBACK
// and let the next statement proceed (by returning false).
//
// We also handwave over the HandlerInterface implementation for
// ThreadMessageQueue. At current, it looks like there can only be one instance
// registered per message type across all threads, which is inconvenient for
// Database2. Worst case, we can just have a singleton helper class which
// receives messages and immediately delegates to the appropraite tx methods.
//
// To support synchronous transactions, we break the methods that execute on
// the background thread in async mode into the part that does the work (names
// end in *Impl()) and the part that sends messages back to the foreground thread.
// Then we can just call the *Impl() methods directly from
// SynchronousTransaction().
//
// To avoid deadlock between async and sync transactions, we keep a static
// counter of the number of open transactions, and only allow a sync transaction
// to be started if it is zero.

class Database2Transaction : ModuleImplBaseClassVirtual {
 public:
  bool StartAsync(Database2Connection *connection) {
    // Increment num_transactions_pending_
    // Call OpenAsync() on some background thread
  }
  
  bool StartSync(Database2Connection *connection) {
    // If num_transactions_pending_ > 0, throw
    // Else call BeginImpl, ExecuteSqlImpl, etc directly.
  }
  
  void OpenAsync() {
    // ThreadMessageQueue::InitThreadMessageQueue()
    // OpenImpl()
    // call OpenCallback on foreground thread
    // wait for result
    // if there was an exception: RollbackAsync()
  }
  
  void OpenImpl() {
    // Initialize connection if not already
    // execute BEGIN
    // open question: deferred or immediate transactions?
    //  note: deferred synchronous transactions lead to deadlock without further precautions :(
    // store any error
  }
  
  void OpenCallback(Database2MessageData *message) {
    // if there was a sql error, invoke failure_callback
    // otherwise:
    // - invoke start_callback
    // - if callback threw: mark closed, save exception message
  }
  
  // IN: string sql, optional object[] arguments, optional function on_success,
  //     optional function on_failure
  // OUT: Database2ResultSet
  void ExecuteSql(JsCallContext *cx) {
    if (!is_open) {
      // throw exception saying the transaction is closed
    }
  
    // create Database2Statement with sql, arguments, and callbacks
    // if async, call ExecuteAsync(stmt) on background thread
    // otherwise:
    //   create resultset
    //   call ExecuteImpl()
    //   functor will populate resultset directly
    //   if success, return resultset
    //   else, throw error
  }
  
  void ExecuteAsync(Database2Statement *stmt) {
    // call ExecuteImpl()
    // functor will populate rows property on stmt (if stmt has sucess callback)
    // add any error to stmt
    // if the appropriate callback exists, call Executecallback(stmt) on foreground thread
    // wait for result
    // if statement succeeded and callback failed: Rollback()
    // else if statement failed and there is no callback, or callback did not return false: Rollback()
    
    // decrement num_statements_pending_;
    // if no more pending statements: CommitAsync();
  }
  
  void ExecuteImpl(Database2Statement *stmt, Functor handle_row_data) {
    // bind args
    // for each row, call handle_row_data
    // close
  }
  
  void ExecuteCallback(Database2Statement *stmt) {
    // if success:
    // - create resultset
    // - populate rows object with intermediate results from stmt
    // - invoke stmt->success_callback;
    // else, call stmt->failure_callback;
  }
  
  void RollbackAsync() {
    // RollbackImpl()
    // Call RollbackCallback() on foreground thread
  }
  
  void RollbackImpl() {
    // execute ROLLBACK
    // mark tx closed
    // decrement num_transactions_pending_
  }
  
  void RollbackCallback() {
    // invoke failure_clalback
  }
  
  void CommitAsync() {
    // CommitImpl()
    // If an appropriate callback exists, call CommitCallback() on foreground thread
  }
  
  void CommitImpl() {
    // execute COMMIT
    // mark tx closed
    // decrement num_transactions_pending_
  }
  
  void CommitCallback() {
    // call appropriate callback
  }

  int last_sql_error_code() const;
  std::string16 &last_error_message() const;

 private:
  static AtomicWord num_transactions_pending_;

  scoped_ptr<JsRootedCallback> start_callback_;
  scoped_ptr<JsRootedCallback> success_callback_;
  scoped_ptr<JsRootedCallback> failure_callback_;

  scoped_refptr<Database2Connection> connection_;

  bool is_open_;
  bool is_async_;
  Atomicword num_statements_pending_;

  int last_sql_error_code_;
  std::string16 last_error_message_;
};


// Base class used for messages passed between threads in
// Transaction.
class Database2MessageData : MessageData {
 public:
  // necessary gunk to wait on this message
};


// Represents a statement queued for execution by a call to
// executeSql().
class Database2Statement : Database2MessageData {
 public:
  std::string16 sql;
  JsParamToSend *args;
  scoped_ptr<JsRootedCallback> success_callback;
  scoped_ptr<JsRootedcallback> failure_callback;
  JsParamToSend *rows;
};
}}}

== Nested Transactions ==

The spec has no concept of nested transactions. Since all transactions are asynchronous, they are just queued naturally by the locking behavior of the database. This is fine for asynchronous transactions. For synchronous transactions, though, it leads to deadlock:

{{{
db.synchronousTransaction(function(tx) {
  db.synchronousTransaction(function(tx) {
  });
});
}}}

Neither transaction will ever complete because they are both waiting on each other. Note that this occurs even if the parent transaction is asynchronous. For this reason, synchronousTransaction() throws if any other transaction is currently running or pending.


== Connection State ==

Many database implementations have per-connection state that should be shared between all statements executing against the connection. For example, SQLite has the last_insert_rowid() function. Connection state should be shared between all transactions created from the same !GearsDatabase2 object.


== Versioning ==

Version information will be stored in a special table, access or changes to are prohibited by the API. !WebKit uses `__WebKitDatabaseInfoTable__`. Perhaps name it along the same lines, like `__HTML5DatabaseInfoTable__`.

To keep up with the version changes across multiple browser windows or workers, either of the following has to be done:

 * the actual version read and compared with the expected at each transaction preflight. If the versions are different, all statements in transaction are marked bogus.
 * make all instances of database object aware of version changes by managing a static map of versions.

The latter approach is what !WebKit team chose, but it may not be possible to implement across all browsers.

_TODO(dglazkov):_ I don't believe we can ensure that in IE? need to research/confirm.
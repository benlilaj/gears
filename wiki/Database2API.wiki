#summary A proposal to add native HTML5 SQL API to Gears
#labels DesignDoc,WorkInProgress

Work in progress
----

= Introduction =

This proposal aims to implement a Gears module based on the existing specification, [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML5 Storage API]. This specification is currently implemented in the [http://trac.webkit.org/projects/webkit/browser/trunk/WebCore/storage WebKit trunk]. There is also an incomplete [http://attic.glazkov.com/player/ player] implementation, written in Javascript as a Gears worker.

=Goals=

The goals of the proposal are:
 * Enable Javascript developers to easily write code that works with both Gears and browser database APIs.
 * Reduce developer "mind-print" by implementing the same API that is available in browsers.
 * Support the proposed HTML5 database standard with an implementation available for all browsers that Gears supports.
 * Implement an asynchronous API that can be called from the UI thread without freezing the UI.
 * Implement a synchronous API to simplify usage inside workers.

Minor/bonus goals:
 * implement a thread pool abstraction that can be used in other modules for asynchronous operations
 * build a new module from scratch using the new Dispatcher model.

Non-goals:
  * Allow current gears databases to work with database2
  * Allow access to database2 from the DOM window object (callers will access database2 through the Gears factory, just like any other Gears object).
  * Allow access to any native browser implementation of HTML5 databases


=Javascript Interface=

The standard interface is defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML 5 specification]. Gears makes some additions for compatibility with native implementations and to add synchronous DB access.


== !DatabaseManager ==

The database manager is the top-level entrypoint to the database2 API in Gears. Callers create instances of it using:

{{{
  google.gears.factory.create('beta.databasemanager');
}}}

!DatabaseManager takes the place of `window.openDatabase()` in the HTML5 spec. Using a different top-level entrypoint allows us to coexist with native browser implementations of the HTML5 database API.

{{{
interface DatabaseManager {
  Database2 openDatabase(in DOMString name,
                         in DOMString version, 
                         in DOMString displayName,
                         in unsigned long estimatedSize);
  // Future: add removeDatabase(), listDatabases()
}
}}}


== Database2 ==

Instances of Database2 are returned by `DatabaseManager.openDatabase()`. Database2 implements the Database interface, as defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#database0 HTML5]. It also implements the following extensions, which allow synchronous Database access:

{{{
interface Database2 {
  void synchronousTransaction(SQLSynchronousTransactionCallback callback)
      throws SQLError;
}

interface SQLSynchronousTransactionCallback {
  void handleEvent(in SQLSynchronousTransaction transaction);
}

interface SQLSynchronousTransaction {
  SQLResultSet executeSql(in DOMString sqlStatement, in ObjectArray arguments)
      throws SQLError;
}
}}}


=Differences from the existing Gears database module=

The API approach differs significantly from the current Gears Database module by introducing an explicit [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqltransaction SQLTransaction] interface. In fact, creating single, transactionless statements is not possible using this API. As a benefit, the management of transactions is completely abstracted out (`BEGIN`, `COMMIT`, `ROLLBACK`, etc. are prohibited in statements).

Because the API is asynchronous, the [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultset SQLResultSet] is an offline dataset, unlike the one in Database. The user accesses row data using an Object, with each field is mapped is a property (see [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultsetrowlist SQLResultSetRowList]).

Additionally, the API includes explicit database version management features in the form of [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#changeversion changeVersion] and an [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#opendatabase openDatabase] version parameter.

There are two types of error callbacks specified, one for transaction, and one for statement. Essentially, the statement error callbacks are used to detect statement sanitizing/execution failures, and the transaction error callbacks are responsible for handling versioning, transaction, and general statement failures.

Unlike the Database module, the spec prescribes limiting available storage for each database.


=Code Example=

{{{
var dbman = goolge.gears.factory.create('beta.databasemanager');
var db = dbman.open('pages', '0.0.1.0',
  'Collection of crawled pages', 3000000);

function renderPageRow(row) {
  // insert page row into a table
}

function reportError(source, message) {
  // report an error
}

function renderPages() {
  db.transaction(function(tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS Pages(title TEXT, lastUpdated INTEGER)', 
      []);
    tx.executeSql('SELECT * FROM Pages', [], function(rs) {
      for(var i = 0; i < rs.rows.length; i++) {
        renderPageRow(rs.rows.item(i));
      }
    })
  })  
}

function insertPage(text, lastUpdated) {
  db.transaction(function(tx) {
    tx.executeSql('INSERT INTO Pages VALUES(?, ?)', [ text, lastUpdated ],
      function() {
        // no result returned, stub success callback
      },
      function(tx, error) {
        reportError('sql', error.message);
      });
  });
}
}}}

There is also a [http://webkit.org/misc/DatabaseExample.html working example] (requires [http://nightly.webkit.org/ WebKit nightly]) on webkit.org


=Technical Design=

All Javascript interfaces are implemented as `ModuleImplBaseClassVirtual` sub-classes and handle retrieving JS arguments, passing return parameters, and invoking callbacks:

{{{

// Allows JavaScript to create database objects. Could be extended
// in the future with removeDatabase() and listDatabases().
class Database2Manager : ModuleImplBaseClassVirtual {
 public:
  // IN: string name, string version, string displayName, int estimatedSize)
  // OUT: Database2
  void OpenDatabase(JsCallContext *cx) {
  // create a Database2 instance and pass name and version into it
  // displayName and estimatedSize not used by Gears
  }
};

}}}

The database interface holds a queue of transactions and a reference to a thread abstraction:

{{{

// Implements the HTML5 database interface, which allows the creation
// of transactions. We also have our own proprietary
// synchronousTransaction() method. This class also has a reference
// to a Database2Connection object which it shares with all transactions
// it creates.
class Database2 : ModuleImplBaseClassVirtual {
 public:
  // IN: function start_callback, function success_callback, function failure_callback)
  // OUT: void
  void Transaction(JsCallContext *cx) {
    Database2Transaction *tx = CreateModule<Database2Transaction>();
    // populate callbacks
    // ...
    QueueTransaction(tx);
  }

  void QueueTransaction(Database2Transaction *tx) {
    bool first = tx_queue_->IsEmpty();
    // add to transaction queue
    tx_queue_->Push(tx);
    if (first) {
      tx->Start();
      }
  }

  // IN: function start_callback
  // OUT: void
  void SynchronousTransaction(JsCallContext *cx) {
    Database2Transaction *tx = CreateModule<Database2SyncTransaction>();
  
    // sync transaction never enters the queue, there's no need for it
    if (!(tx_queue_->IsEmpty() && tx->Start(connection))) {
      // could be because:
      // - there was already a transaction open
      // - opening the transaction failed
      // - any of the statements failed
      // - any of the callback threw an exception
      // - the commit failed
      // if there isn't already an exception set 
    // (tx->is_exception_set()), create
      // one using the error.
    }
  }
  
  // IN: string old version, string new version, optional function callback,
  //     optional function success, optional function failure
  // OUT: void
  void ChangeVersion(JsCallContext *cx) {
    Database2Transaction *tx = CreateModule<Database2Transaction>();
    // populate callbacks
    // + populate version
    // ...
    QueueTransaction(tx);
  }
  
 private:
  // Shared reference to the connection used by all transactions from this
  // database instance. This is initialized during the first transaction.
  scoped_refptr<Database2Connection> connection;
  scoped_refptr<Database2Thread> thread_;
  ThreadSafeQueue<Database2Transaction> tx_queue_;
};

}}}

With the exception of opening a database, which has to occur on the main thread,  all database operations follow the same pattern: a database statement is executed on a separate thread, then an optional action on the main thread follows. This pattern is encapsulated by `Database2Thread`, which acts as a simple interpreter, accepting a `ThreadedOperationInterface` and executing it.

The execution first invokes `InBackground` method of the interface on a separate thread, then, when the method completes and returns `true`, invokes `OnForeground` method back on the main thread. This is accomplished by passing messages using a `ThreadMessageQueue`:

{{{
// lazily creates a background thread
// could be a thread pool
class Database2Thread : RefCounted {
 private:
  void ThreadEntryPoint() {
   // pump, pump, pump
  }
 public:
  ~Database2Thread() {
   // shut down thread, if started
  }
 
  void QueueOperation(ThreadedOperationInterface* item) {
   // get ThreadMessageQueue instance
   // post item message
   // on the background thread, invoke InBackground, then
   // if returned true,
   // post item back to the foreground thread,
   // when the message is received, invoke OnForeground
  }
};

class ThreadedOperationInterface : MessageData {
 // return false, if no need to report results
 virtual bool InBackground() = 0;
 virtual void OnForeground() = 0;
};

}}}

It is important to note that `QueueOperation` method should be callable from any thread with the same result: main thread is the one in which `Database2Thread` was instantiated.

Each concrete implementation of `ThreadedOperationInterface` acts as operation context, holding refs to all work objects and results. There are several implementations of `ThreadedOperationInterface`, each for one database operation and each handling the corresponding fallback/error cases:

 * `BeginTransactionOperation`
 * `ExecuteSqlOperation`
 * `CommitTransactionOperation`
 * `RollbackTransactionOperation`
 
Here's the rough sketch of an `ExecuteSqlOperation`:
 
{{{

class ExecuteSqlOperation : ThreadedOperationInterface {
 public:
  ExecuteSqlOperation(Database2Transacton *tx,
                      Database2Connection *conn,
                      Database2Statement *stmt) : tx_(tx), stmt_(stmt),
                       conn_(conn) {}
  
  bool InBackground() {
   // this operation is also the functor for retrieving rows
   conn_->Execute(stmt, this);
    // functor will populate rows property on stmt (if stmt has success   
    // callback)
    // store error, if any
    // if success and no success callback:
     tx->ExecuteNextStatement();
     return false;
    // otherwise, delegate to foreground thread
    return true;
  }
  
  void OnForeground() {
    stmt_->InvokeCallback(/* collected rows */);
    // if statement succeeded and callback failed, queue rollback op
    // else if statement failed and there is no callback, or callback did
    // not return false, queue rollback op
  }
  
  // I am the glorious el Functoro
  void operator()(/* args go here */) {
   // collect a row
  }
  
 private:
  int sql_error_code_;
  std::string16 last_error_message_;

  Database2Transaction *tx_;
  Database2Connection *conn_;
  Database2Statement *stmt_;
};

}}}

The implementation of the `SQLTransaction` interface holds a queue of statements and provides facilities to invoke transaction callbacks:

{{{

class Database2Transaction : ModuleImplBaseClassVirtual {
 public:
  void Start() {
    // queue operation to begin transaction
    thread()->QueueOperation(new BeginTransationOperation(this, database()));
  }

  void InvokeCallback();

  void InvokeErrorCallback();
  
  // IN: string sql, optional object[] arguments, optional function on_success,
  //     optional function on_failure
  // OUT: Database2ResultSet
  void ExecuteSql(JsCallContext *cx) {
    if (!is_open) {
      // throw exception saying the transaction is closed
    }
    // create Database2Statement with sql, arguments, and callbacks
    // add to statement queue
    // if first item in the queue, invoke ExecuteNextStatement
    
    // ideally, if the queue is empty prior to this call, this should be done
    // without pushing/popping the statement
  }

  void ExecuteNextStatement(JsCallContext *cx) {
    // pop statement from the end of the queue
    // if no more statements,
    thread()->QueueOperation(new CommitTransactionOperation(this));
    // otherwise
    thread()->QueueOperation(CreateExecuteOperation(stmt, cx));
  }

  Database2Connection database() const;
 
 protected:
  
  virtual Database2Thread thread();
  virtual ThreadedOperationInterface 
    CreateExecuteOperation(Database2Statement* stmt,
                           JsCallContext* cx) const;
  virtual ThreadedOperationInterface
    CreateBeginTransactionOperation() const;
  
 private:
  std:string16 old_version_;
  std:string16 new_version_;

  scoped_ptr<JsRootedCallback> start_callback_;
  scoped_ptr<JsRootedCallback> success_callback_;
  scoped_ptr<JsRootedCallback> failure_callback_;

  scoped_refptr<Database2Connection> connection_;
  scoped_refptr<Database2Thread> thread_;
  
  ThreadSafeQueue<Database2Statement> statement_queue_;

  bool is_open_;
};

}}}

Thus, there are two explicit, thread-safe queues: a transaction queue and a statement queue. Each `Database2Transaction` has a statement queue. The queues are concrete implementations of a `ThreadSafeQueue` template:

{{{

// thread-safe queue, used to queue up both transactions and statements
template <class T>
class ThreadSafeQueue {
 public:
  Push(T *t) {
   // lock
   // add t to internal queue
   // unlock
  }
  
  // remove from queue
  T *Pop();
  
  // returns true if the internal queue is empty
  bool IsEmpty();
};

}}}

Database work is encapsulated in the `Database2Connection`. Here is a very rough sketch:

{{{
// Encapsulates database operations, opens and closes database connection
class Database2Connection : RefCounted {
 public:
  // lazily initialized
  Database2Connection(std:string16 name) : name_(name) {}
  
  ~Database2Connection() {
    // close connection
  }
  
  bool VerifyVersion(std:string16 version) {
    // read and store expected version
    // return true, if argument matches actual version
  }
  
  void Execute((*row_data_callback)(...), (*error_callback)(int, std:string)) {
    if (bogus_version_) {
     // call error_callback, version mismatch
    }
    // prepare
    // step, for each row, call row_data_callback
     // if error, call error_callback with code and message 
  }
 
  bool Open(void (*error_callback)(int, std:string)) {
    // execute BEGIN    
    // if error, call error_callback with code and message
    // read actual_version
  }
 
  void Rollback() {
    // execute ROLLBACK
  }

  bool Commit(void (*error_callback)()) {
    // execute COMMIT
    // if error, call error_callback
  }

 private:
  bool GetHandle() {
    // opend database if not already open,
    // used by all operations to obtain the handle
  }
  
  bool bogus_version_;
  int expected_version_;

  sqlite3 *handle_;
  std:string16 name_;
};

}}}

In order to handle synchronous transactions, a sub-class of `Database2Transaction` overrides `thread` and `CreateExecuteOperation` methods as follows:

 * `thread` now returns a sub-class (super-class?) of `Database2Thread` that simply invokes `InBackground` and then `InForeground`, without any threading.
 * `CreateExecuteOperation` instantiates a `SyncExecuteOperation`, which stuffs the result set into the passed `JsCallContext` and returns.  

A statement in transaction is represented by `Database2Statement`:

{{{

class Database2Statement {
 private:
  std::string16 sql_;
  JsParamToSend *args_;
  scoped_ptr<JsRootedCallback> success_callback_;
  scoped_ptr<JsRootedcallback> failure_callback_;
  JsParamToSend *rows_;

 public:
  InvokeSuccessCallback();
  InvokeFailureCallback();
};

}}}

Version values are part of `Database2Transaction`, and remain uninitialized when `Database2::Transaction` method is invoked. If they are initialized (this occurs when `Database2::ChangeVersion` is called):

 * `BeginTransactionOperation::InBackground` checks for `bogus_version_` and fails, if the flag is set
 * `CommitTransactionOperation::InBackground` updates version values after successful commit 

== Nested Transactions ==

The spec has no concept of nested transactions. Since all transactions are asynchronous, they are just queued naturally by the locking behavior of the database. This is fine for asynchronous transactions. For synchronous transactions, though, it leads to deadlock:

{{{
db.synchronousTransaction(function(tx) {
  db.synchronousTransaction(function(tx) {
  });
});
}}}

Neither transaction will ever complete because they are both waiting on each other. Note that this occurs even if the parent transaction is asynchronous. For this reason, synchronousTransaction() throws if any other transaction is currently running or pending.


== Connection State ==

Many database implementations have per-connection state that should be shared between all statements executing against the connection. For example, SQLite has the last_insert_rowid() function. Connection state should be shared between all transactions created from the same !GearsDatabase2 object.


== Versioning ==

Version information is tracked using the [http://www.sqlite.org/pragma.html#version user_version] pragma, retrieval of which is a cheap and safe operation across threads or processes.

The actual version values are stored in a central table in _Permissions.db_:
{{{
CREATE TABLE DatabaseVersions(
  name TEXT,
  origin TEXT,
  version TEXT,
  PRIMARY KEY(name, origin)
)
}}}

===openDatabase===

After database is opened and if `databaseVersion` is specified, read `expected_version`:
{{{
PRAGMA user_version
}}}

Then, read `version` from _Permissions.db_
{{{
SELECT version from DatabaseVersions WHERE name = ? 
  AND origin = ?
}}}

If `databaseVersion` and `version` don't match, raise an INVALID_STATE_ERR
exception.

===transaction===

After transaction begins, read `actual_version` using:
{{{
PRAGMA user_version
}}}

if the not the same as `expected_version`, set `bogus_version` flag. This will cause all statements to fail with error code 2.

===changeVersion===

In _preflight_, if `bogus_version` flag is set, fail transaction.

In _postflight_, update _Permissions.db_:
{{{
REPLACE INTO DatabaseVersions(name, origin, version) VALUES(?,?,?)
}}}

Then, bump `expected_version` by 1 and update pragma accordingly:
{{{
PRAGMA user_version = ?
}}}
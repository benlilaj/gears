#summary A proposal to add native HTML5 SQL API to Gears
#labels DesignDoc,WorkInProgress

Work in progress
----

= Introduction =

This proposal aims to implement a Gears module based on the existing specification, [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML5 Storage API]. This specification is currently implemented in the [http://trac.webkit.org/projects/webkit/browser/trunk/WebCore/storage WebKit trunk]. There is also an incomplete [http://attic.glazkov.com/player/ player] implementation, written in Javascript as a Gears worker.

=Goals=

The goals of the proposal are:
 * Enable !JavaScript developers to easily write code that works with both Gears and browser database APIs.
 * Reduce developer "mind-print" by implementing the same API that is available in browsers.
 * Support the proposed HTML5 database standard with an implementation available for all browsers that Gears supports.
 * Implement an asynchronous API that can be called from the UI thread without freezing the UI.
 * Implement a synchronous API to simplify usage inside workers.

Minor/bonus goals:
 * implement a thread pool abstraction that can be used in other modules for asynchronous operations
 * build a new module from scratch using the new Dispatcher model.

Non-goals:
  * Allow current gears databases to work with database2
  * Allow access to database2 from the DOM window object (callers will access database2 through the Gears factory, just like any other Gears object).


=Javascript Interface=

The standard interface is defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML 5 specification]. Gears makes some additions for compatibility with native implementations and to add synchronous DB access.


== !DatabaseManager ==

The database manager is the top-level entrypoint to the database2 API in Gears. Callers create instances of it using:

{{{
  google.gears.factory.create('beta.databasemanager');
}}}

!DatabaseManager takes the place of `window.openDatabase()` in the HTML5 spec. Using a different top-level entrypoint allows us to coexist with native browser implementations of the HTML5 database API.

{{{
interface DatabaseManager {
  Database2 openDatabase(in DOMString name,
                         in DOMString version, 
                         in DOMString displayName,
                         in unsigned long estimatedSize);
  // Future: add removeDatabase(), listDatabases()
}
}}}


== Database2 ==

Instances of Database2 are returned by `DatabaseManager.openDatabase()`. Database2 implements the Database interface, as defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#database0 HTML5]. It also implements the following extensions, which allow synchronous Database access:

{{{
interface Database2 {
  void synchronousTransaction(SQLSynchronousTransactionCallback callback)
      throws SQLError;
}

interface SQLSynchronousTransactionCallback {
  void handleEvent(in SQLSynchronousTransaction transaction);
}

interface SQLSynchronousTransaction {
  SQLResultSet executeSql(in DOMString sqlStatement, in ObjectArray arguments)
      throws SQLError;
}
}}}


=Differences from the existing Gears database module=

The API approach differs significantly from the current Gears Database module by introducing an explicit [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqltransaction SQLTransaction] interface. In fact, creating single, transactionless statements is not possible using this API. As a benefit, the management of transactions is completely abstracted out (`BEGIN`, `COMMIT`, `ROLLBACK`, etc. are prohibited in statements).

Because the API is asynchronous, the [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultset SQLResultSet] is an offline dataset, unlike the one in Database. The user accesses row data using an Object, with each field is mapped is a property (see [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultsetrowlist SQLResultSetRowList]).

Additionally, the API includes explicit database version management features in the form of [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#changeversion changeVersion] and an [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#opendatabase openDatabase] version parameter.

There are two types of error callbacks specified, one for transaction, and one for statement. Essentially, the statement error callbacks are used to detect statement sanitizing/execution failures, and the transaction error callbacks are responsible for handling versioning, transaction, and general statement failures.

Unlike the Database module, the spec prescribes limiting available storage for each database.


=Code Example=

{{{
var dbman = goolge.gears.factory.create('beta.databasemanager');
var db = dbman.open('pages', '0.0.1.0',
  'Collection of crawled pages', 3000000);

function renderPageRow(row) {
  // insert page row into a table
}

function reportError(source, message) {
  // report an error
}

function renderPages() {
  db.transaction(function(tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS Pages(title TEXT, lastUpdated INTEGER)', 
      []);
    tx.executeSql('SELECT * FROM Pages', [], function(rs) {
      for(var i = 0; i < rs.rows.length; i++) {
        renderPageRow(rs.rows.item(i));
      }
    })
  })  
}

function insertPage(text, lastUpdated) {
  db.transaction(function(tx) {
    tx.executeSql('INSERT INTO Pages VALUES(?, ?)', [ text, lastUpdated ],
      function() {
        // no result returned, stub success callback
      },
      function(tx, error) {
        reportError('sql', error.message);
      });
  })
}
}}}

There is also a [http://webkit.org/misc/DatabaseExample.html working example] (requires [http://nightly.webkit.org/ WebKit nightly]) on webkit.org


=Implementation=

== Asynchronous Transactions ==

The proposed asynchronous API allows multiple sql statements to be queued up and processed in order in the background. Each statement can have associated callbacks. When those statements are executed, the callbacks should also be fired in order in the foreground. The transaction completes when there are no more statements to process and no more callbacks to fire.

This implies a design where a foreground and background thread share two queues: a `pending_messages` queue and a `processed_messages` queue. Each time `executeSql()` is called, the foreground thread adds information about the statement to be processed to the `pending_messages` queue. 

The background thread executes each statement in the `pending_messages` queue in order. If a statement has callbacks, the statement is moved to the `processed_messages` queue, where the foreground thread will find it and fire its callbacks.

After each statement is executed, and after each statement's callback is fired, both queue's lengths are checked. If they are both zero, the transaction is complete and is closed.

We can reuse the existing `ThreadMessageQueue` implementation in `base/common/thread_message_queue.h` to send events between the two threads.

We don't yet have cross-platform `CreateThread()`, or `ThreadPool` abstractions. It might be useful to create one or more of those at this time.


== Synchronous Transactions ==

The `synchronousTransaction` method follows these steps:
 # start new transaction
 # if an error occurred in creating transaction, throw a `SQLError` exception
 # execute `SQLSynchronousTransactionCallback`
 # if the callback throws an exception or couldn't be called, throw a `SQLError` exception
 # commit transaction
 # if the transaction couldn't have been committed, throw a `SQLError` exception
 # end

_TODO:_ Dimitri had the idea of a synchronous event queue to decrease differences between the two modes. Flesh that out.


== Lifetime Management ==

Like all other Gears modules that have asynchronous behavior, GearsSQLTransaction should live until all asynchronous operations are complete, even if there are no !JavaScript references to the GearsSQLTransaction instance. Each queued statement and callback should increment the reference count of the corresponding GearsSQLTransaction instance.


== Versioning ==

_TODO:_ Research how to implement this.


=Discussion=

It would be great to provide complementary [http://code.google.com/p/google-gears/issues/detail?id=76 removeDatabase], and [http://code.google.com/p/google-gears/issues/detail?id=49 listDatabases] methods. The proposed module interface would be as follows:

{{{
interface DatabaseManager {
  Database openDatabase(in DOMString name, in DOMString version, 
    in DOMString displayName, in unsigned long estimatedSize);
  void removeDatabase(in DOMString name);
  String[] listDatabases();
}
}}}

The synchronous transaction is more susceptible to deadlocks:

{{{
db.synchronousTransaction(function(tx) {
  var rs = tx.executeSql('SELECT * FROM Pages', []);
    db.synchronousTransaction(function(tx) {
      // deadlock!
    });
    // ..
})  
}}}

A similar problem would also occur if a synchronous transaction is started in either asynchronous transaction or statement callbacks.

As possible solutions, we can count transaction nesting level and:
 * deny the ability to create nested transactions. This would be a runtime exception, which in turn would cause the outer transaction to rollback.
 * fake joining transaction (nesting transactions, [http://www.sqlite.org/lang_transaction.html not supported] by SQLite). This would result in a misleading behavior (i.e. throwing an exception inside of the nested callback won't roll back just the nested transaction) and probably isn't a good option. 

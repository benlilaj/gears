#summary A proposal to add native HTML5 SQL API to Gears
#labels DesignDoc,WorkInProgress

Work in progress
----

= Introduction =

This proposal aims to implement a Gears module based on the existing specification, [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML5 Storage API]. This specification is currently implemented in the [http://trac.webkit.org/projects/webkit/browser/trunk/WebCore/storage WebKit trunk]. There is also an incomplete [http://attic.glazkov.com/player/ player] implementation, written in Javascript as a Gears worker.

=Goals=

The goals of the proposal are:
 * provide a standards-based way to access and manipulate Gears databases
 * implement native asynchronous, transactional database API
 * provide a complementing synchronous cousin to the API, specified in HTML5

Minor/bonus goals:
 * implement a thread pool abstraction that can be used in other modules for asynchronous operations
 * build a new module from scratch using the new Dispatcher model.
 * provide implementation feedback for HTML5 specification

=Javascript Interface=

The interface is defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML 5 specification].

While the `openDatabase` method is a member of DOM window object, the Database2 module will be a standalone interface:

{{{
interface Database2 {
  // creates a new Database object instance
  // name -- name of the database
  // version -- expected version of the database
  // displayName -- friendly name of the database
  // estimatedSize -- estimated size (in bytes) of the database
  Database openDatabase(in DOMString name, in DOMString version, 
    in DOMString displayName, in unsigned long estimatedSize);
}
}}}


=Differences=

The API approach differs significantly from the Gears Database module by introducing an explicit [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqltransaction SQLTransaction] interface. In fact, creating single, transactionless statements is not possible using this API. As a benefit, the management of transactions is completely abstracted out (`BEGIN`, `COMMIT`, `ROLLBACK`, etc. are prohibited in statements).

The API is completely asynchronous. The transaction callback is invoked asynchronously (though on the same thread), and tx.executeSql(...) statements don't actually execute any SQL. Instead, the API is essentially an abstraction around a queueing worker, with the transaction callback being a way to _sequence_ the queue items, and tx.executeSql providing the queue items themselves. 

Because the API is asynchronous, the [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultset SQLResultSet] is an offline dataset, unlike the one in Database. The user accesses row data using an Object, with each field is mapped is a property (see [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultsetrowlist SQLResultSetRowList]).

Additionally, the API includes explicit database version management features in the form of [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#changeversion changeVersion] and an [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#opendatabase openDatabase] version parameter.

There are error two types of error callbacks specified, one for transaction, and one for statement. Essentially, the statement error callbacks are used to detect statement sanitizing/execution failures, and the transaction error callbacks are responsible for handling versioning, transaction, and general statement failures.

Unlike the Database module, the spec prescribes limiting available storage for each database.

=Code Example=

{{{
var html5db = goolge.gears.factory.create('beta.database2');
var db = html5db.open('pages', '0.0.1.0',
  'Collection of crawled pages', 3000000);

function renderPageRow(row) {
  // insert page row into a table
}

function reportError(source, message) {
  // report an error
}

function renderPages() {
  db.transaction(function(tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS Pages(title TEXT, lastUpdated INTEGER)', 
      []);
    tx.executeSql('SELECT * FROM Pages', [], function(rs) {
      for(var i = 0; i < rs.rows.length; i++) {
        renderPageRow(rs.rows.item(i));
      }
    })
  })  
}

function insertPage(text, lastUpdated) {
  db.transaction(function(tx) {
    tx.executeSql('INSERT INTO Pages VALUES(?, ?)', [ text, lastUpdated ],
      function() {
        // no result returned, stub success callback
      },
      function(tx, error) {
        reportError('sql', error.message);
      });
  })
}
}}}

There is also a [http://webkit.org/misc/DatabaseExample.html working example] (requires [http://nightly.webkit.org/ WebKit nightly]) on webkit.org

=Implementation=

Currently, a SQLite statement is prepared, bound, and executed in one method. The HTML5 API suggests that the statement is prepared and bound by the `executeSql` method and then queued up for asynchronous execution. Presumably, any additional sanitizing should occur at that point, as well.

Versions are changed as part of specifically defined pre-flight and post-flight operations, and they appear to be just specialized items in the work queue. Version management is accomplished by storing current database versions in a user-inaccessible database table.

_TODO_: transactions step processing/queue model

=Discussion=

It would be great to provide a complementary `removeDatabase` method and address [http://code.google.com/p/google-gears/issues/detail?id=76&colspec=Version%20Owner%20ID%20Summary%20Component Issue 76]. The proposed module interface would be as follows:

{{{
interface Database2 {
  Database openDatabase(in DOMString name, in DOMString version, 
    in DOMString displayName, in unsigned long estimatedSize);
  void removeDatabase(in DOMString name);
}
}}}
#summary A proposal to add native HTML5 SQL API to Gears
#labels DesignDoc,WorkInProgress

Work in progress
----

= Introduction =

This proposal aims to implement a Gears module based on the existing specification, [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML5 Storage API]. This specification is currently implemented in the [http://trac.webkit.org/projects/webkit/browser/trunk/WebCore/storage WebKit trunk]. There is also an incomplete [http://attic.glazkov.com/player/ player] implementation, written in Javascript as a Gears worker.

=Goals=

The goals of the proposal are:
 * Enable !JavaScript developers to easily write code that works with both Gears and browser database APIs.
 * Reduce developer "mind-print" by implementing the same API that is available in browsers.
 * Support the proposed HTML5 database standard with an implementation available for all browsers that Gears supports.
 * Implement an asynchronous API that can be called from the UI thread without freezing the UI.
 * Implement a synchronous API to simplify usage inside workers.

Minor/bonus goals:
 * implement a thread pool abstraction that can be used in other modules for asynchronous operations
 * build a new module from scratch using the new Dispatcher model.

Non-goals:
  * Allow current gears databases to work with database2
  * Allow access to database2 from the DOM window object (callers will access database2 through the Gears factory, just like any other Gears object).
  * Allow access to any native browser implementation of HTML5 databases


=Javascript Interface=

The standard interface is defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html HTML 5 specification]. Gears makes some additions for compatibility with native implementations and to add synchronous DB access.


== !DatabaseManager ==

The database manager is the top-level entrypoint to the database2 API in Gears. Callers create instances of it using:

{{{
  google.gears.factory.create('beta.databasemanager');
}}}

!DatabaseManager takes the place of `window.openDatabase()` in the HTML5 spec. Using a different top-level entrypoint allows us to coexist with native browser implementations of the HTML5 database API.

{{{
interface DatabaseManager {
  Database2 openDatabase(in DOMString name,
                         in DOMString version, 
                         in DOMString displayName,
                         in unsigned long estimatedSize);
  // Future: add removeDatabase(), listDatabases()
}
}}}


== Database2 ==

Instances of Database2 are returned by `DatabaseManager.openDatabase()`. Database2 implements the Database interface, as defined in [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#database0 HTML5]. It also implements the following extensions, which allow synchronous Database access:

{{{
interface Database2 {
  void synchronousTransaction(SQLSynchronousTransactionCallback callback)
      throws SQLError;
}

interface SQLSynchronousTransactionCallback {
  void handleEvent(in SQLSynchronousTransaction transaction);
}

interface SQLSynchronousTransaction {
  SQLResultSet executeSql(in DOMString sqlStatement, in ObjectArray arguments)
      throws SQLError;
}
}}}


=Differences from the existing Gears database module=

The API approach differs significantly from the current Gears Database module by introducing an explicit [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqltransaction SQLTransaction] interface. In fact, creating single, transactionless statements is not possible using this API. As a benefit, the management of transactions is completely abstracted out (`BEGIN`, `COMMIT`, `ROLLBACK`, etc. are prohibited in statements).

Because the API is asynchronous, the [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultset SQLResultSet] is an offline dataset, unlike the one in Database. The user accesses row data using an Object, with each field is mapped is a property (see [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#sqlresultsetrowlist SQLResultSetRowList]).

Additionally, the API includes explicit database version management features in the form of [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#changeversion changeVersion] and an [http://www.whatwg.org/specs/web-apps/current-work/multipage/section-sql.html#opendatabase openDatabase] version parameter.

There are two types of error callbacks specified, one for transaction, and one for statement. Essentially, the statement error callbacks are used to detect statement sanitizing/execution failures, and the transaction error callbacks are responsible for handling versioning, transaction, and general statement failures.

Unlike the Database module, the spec prescribes limiting available storage for each database.


=Code Example=

{{{
var dbman = goolge.gears.factory.create('beta.databasemanager');
var db = dbman.open('pages', '0.0.1.0',
  'Collection of crawled pages', 3000000);

function renderPageRow(row) {
  // insert page row into a table
}

function reportError(source, message) {
  // report an error
}

function renderPages() {
  db.transaction(function(tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS Pages(title TEXT, lastUpdated INTEGER)', 
      []);
    tx.executeSql('SELECT * FROM Pages', [], function(rs) {
      for(var i = 0; i < rs.rows.length; i++) {
        renderPageRow(rs.rows.item(i));
      }
    })
  })  
}

function insertPage(text, lastUpdated) {
  db.transaction(function(tx) {
    tx.executeSql('INSERT INTO Pages VALUES(?, ?)', [ text, lastUpdated ],
      function() {
        // no result returned, stub success callback
      },
      function(tx, error) {
        reportError('sql', error.message);
      });
  })
}
}}}

There is also a [http://webkit.org/misc/DatabaseExample.html working example] (requires [http://nightly.webkit.org/ WebKit nightly]) on webkit.org


=Implementation=

== General Structure ==

All transactions are serialized. With the previous Database module, we found that allowing concurrent transactions led to hard to understand bugs and began recommending the `BEGIN IMMEDIATE` statement for most users, which forces serialized transactions. In Database2 this will be enforced.

There is a single `TransactionQueue` per physical database which executes each queued transaction in order. It also manages a single background thread for executing the asynchronous transactions.

The background and foreground threads communicate via message passing using [http://code.google.com/p/google-gears/source/browse/trunk/gears/base/common/message_queue.h ThreadMessageQueue].


== Nested Transactions ==

The spec has no concept of nested transactions. Since all transactions are asynchronous, they are just queued naturally by the locking behavior of the database. This is fine for asynchronous transactions. For synchronous transactions, though, it leads to deadlock:

{{{
db.synchronousTransaction(function(tx) {
  db.synchronousTransaction(function(tx) {
  });
});
}}}

Neither transaction will ever complete because they are both waiting on each other. Note that this occurs even if the parent transaction is asynchronous. For this reason, synchronousTransaction() throws if any other transaction is currently running or pending.


== Connection State ==

Many database implementations have per-connection state that should be shared between all statements executing against the connection. For example, SQLite has the last_insert_rowid() function. Connection state should be shared between all transactions created from the same !GearsDatabase2 object.


== Lifecycle/Ownership ==

The diagram below shows the ownership model for Database2:

[http://google-gears.googlecode.com/svn/contrib/aa1/docs/database2_ownership.png]

  # When a Database object is created, it creates and references the !DatabaseConnection object
  # The first time a transaction is started for a database, a !TransactionQueue is created for that database
  # When a transaction is started, two objects are created: A JS-facing object that represents the transaction and is subject to GC, and an internal object which is where the real work happens. We separate the two so that we can reuse the concept of ref-counting for a transaction's lifetime without the JS engine's GC keeping transactions open arbitrarily long.
  # Each transaction that is created holds a reference to its !TransactionQueue.
  # Each statement that is added to a transaction holds a reference to its transaction.
  # Once a statement is processed, it is deleted and drops its reference.
  # Once all statements for a transaction have been processed, the transaction commits itself, deletes itself, and drops its reference to its !TransactionQueue.
  # Once all transactions are completed, the !TransactionQueue itself is deleted.


== Versioning ==

Version information will be stored in a special table, access or changes to are prohibited by the API. !WebKit uses `__WebKitDatabaseInfoTable__`. Perhaps name it along the same lines, like `__HTML5DatabaseInfoTable__`.

To keep up with the version changes across multiple browser windows or workers, either of the following has to be done:

 * the actual version read and compared with the expected at each transaction preflight. If the versions are different, all statements in transaction are marked bogus.
 * make all instances of database object aware of version changes by managing a static map of versions.

The latter approach is what !WebKit team chose, but it may not be possible to implement across all browsers.

_TODO(dglazkov):_ I don't believe we can ensure that in IE? need to research/confirm.

=Discussion=

It would be great to provide complementary [http://code.google.com/p/google-gears/issues/detail?id=76 removeDatabase], and [http://code.google.com/p/google-gears/issues/detail?id=49 listDatabases] methods. The proposed module interface would be as follows:

{{{
interface DatabaseManager {
  Database openDatabase(in DOMString name, in DOMString version, 
    in DOMString displayName, in unsigned long estimatedSize);
  void removeDatabase(in DOMString name);
  String[] listDatabases();
}
}}}

The synchronous transaction is more susceptible to deadlocks:

{{{
db.synchronousTransaction(function(tx) {
  var rs = tx.executeSql('SELECT * FROM Pages', []);
    db.synchronousTransaction(function(tx) {
      // deadlock!
    });
    // ..
})  
}}}

A similar problem would also occur if a synchronous transaction is started in either asynchronous transaction or statement callbacks.

As possible solutions, we can count transaction nesting level and:
 * deny the ability to create nested transactions. This would be a runtime exception, which in turn would cause the outer transaction to rollback.
 * fake joining transaction (nesting transactions, [http://www.sqlite.org/lang_transaction.html not supported] by SQLite). This would result in a misleading behavior (i.e. throwing an exception inside of the nested callback won't roll back just the nested transaction) and probably isn't a good option. 

Low priority: Let's also see if we can support the event handler object syntax (an object with `handleEvent` method as a callback argument, rather than a function).
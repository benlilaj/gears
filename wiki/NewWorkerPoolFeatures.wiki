#summary Proposal for new WorkerPool features to improve usability

= Introduction =

WorkerPool has a couple issues today that make it hard to get started with:

  * Errors do not get reported anywhere by default, making it hard to get going at first.
  * The code to run in the worker has to get passed in as a string - most AJAX applications do not have access to their code as a string, and this also makes it hard to have the worker have dependencies.
  * There's no debugger support in most browsers.
  * The simple use case - RPC calls - are not well supported: you must send the worker a message, and it sends you a separate response. You have to link them together yourself.
  * You need to set google.gears.workerPool.onmessage or you get an error. This makes the minimal worker code that does anything quite large. It should be possible to do smaller 'Hello world!' 

This proposal addresses these issues by making the following changes:

  * Add WorkerPool.load();
  * Add WorkerPool.onerror;
  * Support for the defacto standard Console object
  * Implement RPC-style sendMessage calls
  * Remove the requirement to set google.gears.workerPool.onmessage inside workers

= WorkerPool.load() =

You should be able to load the contents of multiple JavaScript files to start a Worker. This is easier for web developers since the typical way to organize AJAX applications is into multiple interdependent JS files.

{{{
var wp = google.gears.factory.create("beta.workerpool", "1.1");
var workerId = wp.load(["foo.js", "bar.js", "baz.js"]);
// load() is async. sendMessage's that happen before the worker is loaded are queued
// and send when load is complete.
wp.sendMessage("muah!", workerId);
}}}


= WorkerPool.onerror =

WorkerPool should expose an optional onerror callback property.

If this function is not set, all errors that happen inside a worker should be re-thrown globally into the window containing the worker.

If the function is set, then all errors that happen inside the worker are routed to the function, which can be used for logging, etc.

{{{
var wp = google.gears.factory.create("beta.workerpool", "1.1");
// Optional property. If not set, something equivalent to
// window.setTimeout(function() { throw new Error(); }, 0) happens when worker errors
// occur. Note that this error handling should catch load errors, parse errors, and
// errors in sendMessage().
wp.onerror = function(e) {
  myLogger.logWorkerError(e);
};
var workerId = wp.load(["buggy.js"]);
}}}


= Support the defacto standard Console object in Workers =

When [http://www.getfirebug.com/ Firebug] is installed, it adds a very useful object called [http://www.getfirebug.com/console.html Console] to the global javascript scope. This object is quickly becoming a defacto standard for logging and debugging in various libraries and toolkits and we should support it too!

This would reduce the minimum observable worker example to:

{{{
// parent code
var wp = google.gears.factory.create("beta.workerpool", "1.1");
wp.load(["test.js"]);

// test.js
console.log("hello world!");
}}}

It's a bit tricky what this API should do if `console` is not defined in the parent window. My thinking is that it shouldn't do anything at all. So basically the implementation of all the console methods would just delegate to the global object called `console` in the parent window, if there is one. That way we would just magically work with whatever is implementing the interface, be it Firebug, or some JS library.


= Implement RPC-style sendMessage calls =

The common use case for workers is probably to tell it to do a single action which will take awhile, and then have it tell you when it is done.

Especially with the lack of XHR and timers in workers, it's hard to imagine that:

{{{
Parent           Worker
start-sync  ->  
            <-   do-xhr
xhr-result  ->
                 dbexec()
            <-   do-xhr
xhr-result  ->
                 ..etc...
}}}

Is any better than:
{{{
Parent           Worker
xhr()
handle-sync ->  
                 dbexec()
xhr()
handle-sync ->
                 dbexec()
... etc ...
}}}

To do this, what you really want is more of an RPC-style interface:

{{{
// Parent code:
var wp = google.gears.factory.create("beta.workerpool", "1.1");
var workerId = wp.load(["a.js", "b.js"]);
wp.sendMessage("handle-sync", {data: here, can: [be, complex, json]}, function(result) {
  alert("Message completed with result: " + result);
});

// Worker code:
google.gears.currentWorker.setMessageHandler("handle-sync", function(args) {
  // do intensive work
  return {complex: jsonresult};
});
}}}
#summary Proposal for new WorkerPool features to improve usability

= Introduction =

!WorkerPool has a couple issues today that make it hard to get started with:

  * Errors do not get reported anywhere by default, making it hard to get going at first.
  * The code to run in the worker has to get passed in as a string - most AJAX applications do not have access to their code as a string, and this also makes it hard to have the worker have dependencies.
  * There's no debugger or logging support in most browsers.
  * You need to set google.gears.workerPool.onmessage or you get an error. This isn't intuitive. Most people's first attempt seems to be to put "hello?" or something simple in the worker code.

This proposal addresses these issues by making the following changes:

  * Add !WorkerPool.load();
  * Add !WorkerPool.onerror;
  * Support for the defacto standard Console object
  * Remove the requirement to set google.gears.workerPool.onmessage inside workers

= WorkerPool.load() =

You should be able to load the contents of multiple !JavaScript files to start a Worker. This is easier for most web developers since it is similar to the way that windows are loaded.

{{{
var wp = google.gears.factory.create("beta.workerpool", "1.1");
var workerId = wp.load(["foo.js", "bar.js", "baz.js"]);
// load() is async. sendMessage's that happen before the worker is loaded are queued
// and send when load is complete.
wp.sendMessage("muah!", workerId);
}}}


= WorkerPool.onerror =

!WorkerPool should expose an optional onerror callback property.

If this function is not set, all errors that happen inside a worker should be re-thrown globally into the window containing the worker (the same thing that happens when you do `window.setTimeout(function() { throw new Error('oops') }, 0)`.

If the function is set, then all errors that happen inside the worker are routed to the function, which can be used for logging, etc.

{{{
var wp = google.gears.factory.create("beta.workerpool", "1.1");
// Optional property. If not set, error is thrown globally.
wp.onerror = function(e) {
  myLogger.logWorkerError(e);
};
var workerId = wp.load(["buggy.js"]);
}}}


= Support the defacto standard Console object in Workers =

When [http://www.getfirebug.com/ Firebug] is installed, it adds a very useful object called [http://www.getfirebug.com/console.html console] to the global javascript scope. This object is quickly becoming a defacto standard for logging and debugging in various libraries and toolkits and we should support it too!

So you could do things like:

{{{
// parent code
var wp = google.gears.factory.create("beta.workerpool", "1.1");
wp.load(["test.js"]);
sp.sendMessage("hello!");

// test.js
google.gears.workerPool.onmessage = function(message, senderId) {
  console.log("worker got message %s from sender %s", message, sender);
}}}

An easy way for Gears to implement this API is to just delegate to whatever is defined as `console` in the containing window's global scope.

That way we would just magically work with whatever is implementing the interface, be it Firebug, or some JS library.


= Remove the requirement to set onmessage in workers =

Even though a worker that doesn't receive messages has limited functionality, it's still userful. You can imagine one-off workers that already know what they need to do. They don't require any messages.

Together with `console` support, above, this reduces the minimum observable worker example to:

{{{
// parent code
var wp = google.gears.factory.create("beta.workerpool", "1.1");
wp.load(["test.js"]);

// test.js
console.log("hello!");
}}}

Developers can then add-in message handling as necessary.
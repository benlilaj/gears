#summary A proposal for supporting resumable POST/PUT HTTP requests in HTTP/1.0.
#labels DesignDoc

= Introduction =

Current web standards provide no reliable mechanism to facilitate the HTTP upload of large files. As a result, file uploads at Google and other sites have traditionally been limited to moderate sizes (e.g. 100 MB), with browser-external clients being required to upload larger files. Several such clients have been created for Google Video, !YouTube, and Google Books, all using HTTP to upload large files by POSTing one segment (a.k.a. chunk) at a time, with chunk sizes on the order of 1 MB; this facilitates recovery from transient errors that occur during upload, by providing well-defined points at which the upload could be resumed (i.e. chunk boundaries). We propose an HTTP/1.0 protocol which provides native support for resuming HTTP requests which aren't currently resumable, such as POST and PUT. While our protocol adheres to HTTP/1.1, it avoids constructs which can not be dealt with properly by HTTP/1.0 proxies. For cases where HTTP/1.0 proxies are not a constraint, we have a separate, but very similar, proposal: ResumableHttp11RequestsProposal.

If an HTTP connection is closed prior to the client receiving a response from the server, the client has no way of knowing how much of the content was successfully received by the server, or whether the operation completed. When this occurs, idempotent operations can be automatically retried, but in the case of non-idempotent operations HTTP/1.1 section 8.1.4 explicitly forbids the client from retrying the operation without user interaction. In order to reattempt the operation without concern for introducing unintended side effects, the server and client require a mechanism for uniquely identifying the operation across multiple requests. We thus require that each upload operation be assigned a unique, per-upload URL, whose generation is outside the scope of the resumable upload protocol itself.

When an HTTP _request_ is resumed, the initial request combined with all subsequent resume requests together constitute a single logical _operation_. As such, we use the terms request and operation, respectively, to distinguish between individual HTTP requests and the combined unit of requests (the original request plus any retries) that are logically associated with each other.

= Protocol Overview =

 # Prior to initiating an operation, the client must first obtain a unique per-operation URL which will be used to identify all subsequent resume requests with the original operation. In other words, all requests to a given URL form a single logical operation.
 # The client initiates a request (e.g. POST/PUT) to the unique URL obtained in step (1). Normally the client sends all data bytes in the initial request, but when necessary it can send partial data, in which case a 412 (Precondition Failed) response code is expected.
 # Once the server has received all bytes of the request, it responds with a final response code, and the operation is complete. If not all data bytes have been received, then the server responds with a 412 (Precondition Failed) response code, indicating that the transferred bytes were succesfully received, but additional bytes are still expected.
 # Should the connection be closed prior to the arrival of a final response code (possibly before all bytes of the request have even been sent), or if the client receives a 503 (Service Unavailable) status code, then the client queries the server by sending a resume request (e.g. POST/PUT) with no body.
 # If the server has succesfully received all bytes from the operation, it responds with a final status code; otherwise it responds with a 412 (Precondition Failed), indicating which bytes of the operation it has successfully received.
 # If the client receives a 412 (Precondition Failed), it sends a resume request, which resembles the original request from step (2), but contains only a subset of the data bytes (specifically those not yet received by the server). An If-Resume header is added to specify the byte range which is being transfered.

= Unique URL =

The core logic of this protocol specification requires a unique per-upload URL, which can be used to 1) send initial requests, 2) send HEAD requests, and 3) send resume requests. In other words, different upload operations MUST each be assigned a unique URL, allowing proper server-side identification of each unique operation. The generation of this unique URL is outside of the scope of the protocol, but we do note that in cases where it is generated by an asynchronous request (versus being embedded in a web page, for example) then the 201 (Created) status code is one natural way to for the server to map a shared upload URL to a unique per-upload URL.

= Initial Request =

Normally there is nothing special about the initial request in a resumable operation. Specifically, it should contain the entire byte range, and not include an If-Resume header. While the protocol itself supports sending a partial range in the initial request, this is recommended against unless explicitly required.

= Status Code: 412 Precondition Failed =

Upon receiving the content body of a resume request, the server may still not posses the complete byte range, requiring further action (e.g. additional requests) from the client. In such cases, the server SHOULD return status code 412 (Precondition Failed) if it is still willing to continue the operation.

412 (Precondition Failed) responses MAY include a Resume-Range header, similar to the Range header as defined in HTTP/1.1 section 14.35. The presence of a Resume-Range header in this context indicates the byte ranges of the content body which the server has stored for this operation. In future resume requests, the client SHOULD use this information to minimize the amount of data that needs to be retransmitted. This header overrides the value of any previous Resume-Range headers, even if the new Resume-Range is not a superset of previous ranges (which allows for the possibility of the server losing or discarding data). In addition, the server MAY specify disjoint byte ranges but SHOULD represent the ranges in canonical form. In the absence of any such Resume-Range header over the course of the operation, the client should assume that the server has no stored bytes.

{{{
resume-range = "Resume-Range" ":" ranges-specifier
}}}

412 (Precondition Failed) responses MAY include a Location header as defined in HTTP/1.1 section 14.30. The presence of a Location header in this context specifies the URI to which future resumable requests should be sent for this operation. The header overrides the value of any previous Location headers. In the absence of any such Location header over the course of the operation, the client should send resume requests to the original Request-URI.

A 412 (Precondition Failed) MAY include a Retry-After header as defined in HTTP/1.1 section 14.37. A client which receives a Retry-After SHOULD delay further resume operations for the specified time period. If the delay is not feasible, the client MUST fail the operation. The server MAY send a 412 (Precondition Failed) before receiving the entire request body, but as specified in section 8.2.3 of HTTP/1.1 the server SHOULD NOT close the transport connection until it has read the entire request, or until the client closes the connection.

Servers MUST NOT send 412 (Precondition Failed) responses in the face of fatal errors. By definition, the 412 (Precondition Failed) response indicates that the client can rectify the current error condition by sending the bytes which the server is missing, and thus the respose code MUST only be sent in this scenario.

= Status Code: 416 Requested Range Not Satisfiable =

When resuming an operation, clients SHOULD send byte ranges that are contiguous with the bytes already acknowledged by the server. Servers MAY support the transfer of non-contiguous byte ranges, but are not required to do so; if a server does not support non-contiguous byte ranges, then it MUST  to them respond with a 416 (Requested Range Not Satisfiable). If the server has succesfully received any bytes from the client, then the 416 (Requested Range Not Satisfiable) response MUST include a Resume-Range header acknowledging those bytes.

When a client receives a 416 (Requested Range Not Satisfiable), if it chooses to continue the operation then it MUST send a range that that is contiguous to the bytes contained in the Resume-Range header of the 416 (Requested Range Not Satisfiable), or starting at the beginning of the byte range if no such header was received.

= If-Resume Header =

The If-Resume header MUST be sent by clients on all resume requests, and MUST be sent on initial requests that contain a partial byte range. The If-Resume header has one optional parameter: bytes.

{{{
if-resume = "If-Resume" ":" [ if-resume-spec ]
if-resume-spec = bytes-if-resume-spec
bytes-if-resume-spec = bytes-unit "=" [ first-byte-pos "-" [last-byte-pos] ] "/" ( instance-length | "*" )
}}}

When including a body in an If-Resume request, clients MUST include an if-resume-spec indicating which bytes are being transferred with respect to all bytes in the operation. Note that this may be different than the byte range specified in any Content-Range header (if present). Clients MUST specify first-byte-pos if any bytes are being transferred (i.e. if the byte range is not zero), otherwise they MUST omit both first-byte-pos and last-byte-pos. Clients MAY omit last-byte-pos in cases where the length of the range being transferred is unknown or difficult to determine. Clients SHOULD specify instance-length, unless it is unknown or difficult to determine (in which case "`*`" should be used). In cases where the instance-length is "`*`", the client MUST either use chunked transfer coding or specify the instance-length in the final chunk transferred. Once a client specifies instance-length on one request, all subsequent requests to the same URL MUST use the same instance-length.

The client MAY send an If-Resume without an if-resume-spec parameter in order to poll the server to determine which byte ranges it already possesses. In such cases, clients MUST NOT include a body in the request. This is the canonical polling mechanism whereby the client can determine which bytes the server has received under failure modes where this information is not already expossed.

= Resuming Operations =

The server SHOULD process the data from a resumable operation in the same way it would have processed a single request with the entire content. In particular, the server may need to cache the partial data from an operation, and only process it (e.g. pass it to a CGI application) once the data is complete. Servers which support a streaming mode of processing may do so for a resumable operation as long as the streaming can be resumed normally when the client sends more data in a future resume request.

If a client's connection to the server is terminated prior to the receipt of a final response code, or if the client receives a 503 (Service Unavailable), exponential backoff should be used to separate series of sequential retries, per HTTP/1.1 section 8.2.4.

If the client sends a resume request which refers to an operation that has already completed, the server MUST NOT re-process the data, and SHOULD return the same or equivalent response to the client as was returned from the original processing. If the server cannot compose an equivalent response, it MAY return 202 or some other response to indicate that the operation was processed with unknown results, keeping in mind that this response might be confusing when resuming requests occur transparently to the user. Regardless of this possibility, any sequence of resume requests with respect to the same entity tag are guaranteed idempotent, and may be retried without user interaction, despite the considerations of section 8.1.4 of HTTP/1.1.

= Use Cases =

The client would begin by sending a single POST/PUT containing the entire (potentially large) body, and then if the connection were prematurely terminated it could issue a HEAD request to determine at which byte range to recommence, at which point all remaining bytes would again be sent in a single POST/PUT. This process would repeat until the last byte was successfully transferred and a response was received from the server. While this should be the standard mode of operation, alternatively a client could dynamically or deterministically break a large POST/PUT into multiple pieces, sending each one separately with an appropriate If-Resume header.

= Related Work =

== RFC 2616: HTTP/1.1 ==

http://www.w3.org/Protocols/rfc2616/rfc2616.html

|| 3.6.1 || Protocol Parameters: Chunked Transfer Coding ||
|| 8.1.4 || Connections: Practical Considerations ||
|| 8.2.4 || Connections: Client Behavior if Server Prematurely Closes Connection ||
|| 9.5 || Method: POST ||
|| 9.6 || Method: PUT ||
|| 10.4.13 || Status Code: 412 Precondition Failed ||
|| 10.4.17 || Status Code: 416 Precondition Failed ||
|| 14.16 || Header Field: Content-Range ||
|| 14.21 || Header Field: Expires ||
|| 14.24 || Header Field: If-Match ||
|| 14.27 || Header Field: If-Range ||
|| 14.30 || Header Field: Location ||
|| 14.35 || Header Field: Range ||
|| 14.41 || Header Field: Transfer-Encoding ||
|| 19.2 || Appendix: Internet Media Type multipart/byteranges ||

== XMLHttpRequest ==

http://www.w3.org/TR/XMLHttpRequest/

== Related Google Gears APIs ==

  * ResumableHttp11RequestsProposal
  * ContentRangePostProposal
  * GearsHttpRequestProposal
  * [BlobAPI]
